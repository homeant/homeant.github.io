[{"content":"moviepilot 刷流教程 准备工作 准备认证合作token 打开爱语飞飞获取token 安装 moviepilot 编写 docker compose 文件 新建docker-compose.yml文件\n1 vi docker-compose.yml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 services: moviepilot: stdin_open: true tty: true container_name: moviepilot-v2 hostname: moviepilot-v2 networks: - trim-default ports: - 3000:3000 # 映射的端口 volumes: - 挂载的文件目录:/media environment: - NGINX_PORT=3000 - PORT=3001 - PUID=0 - PGID=0 - UMASK=000 - TZ=Asia/Shanghai - AUTH_SITE=iyuu - IYUU_SIGN=iyuu微信扫码后，公总号回复你的token - SUPERUSER=admin - API_TOKEN=后续调用mp的api_token，16位以上 restart: always image: jxxghp/moviepilot-v2:latest # mp的镜像 networks: trim-default: external: true 启动 mp 1 docker compose -f docker-compose.yml up -d 查看 mp 登录密码 1 docker logs moviepilot-v2 | grep \u0026#39;密码\u0026#39; 1 INFO: 294b007932ef_2_0_0.py - 【超级管理员初始密码】lthJL2ATiVNTQPVCuj31lg 请登录系统后在设定中修改。 注：该密码只会显示一次，请注意保存。 检查 IYUU 是否认证成功 1 docker logs moviepilot-v2 | grep \u0026#39;iyuu 用户\u0026#39; 1 INFO: modules_initializer.py - iyuu 用户认证成功！ 配置 mp 浏览器打开，并输入mp访问地址进行登录\n配置站点 打开左侧菜单站点管理\u0026gt; 右下角+ 进行站点配置 注意：\n馒头站点需要选择API配置方式 其他站点选择COOKIE配置方式，比如冰激凌、阿童木、明教等 获取 Authorization 1、登录馒头站点，在浏览器中按F12键，打开开发者工具\n2、刷新页面，点击开发者工具中的网络(network)\u0026gt;过滤条件选择Feteh/XHR\u0026gt;选择下面任意一个请求并点击\n3、在请求头中找到Authorization，复制Authorization的值\n获取 API_EKY 1、登录馒头站点\n2、依次点击导航控制台\u0026gt;实验室\n3、在实验室页面中找到存取令牌，如果没有点击建立存取令牌，然后复制\n获取 Cookie 1、登录其他站点，比如冰激凌、阿童木、明教等\n2、在浏览器中按F12键，打开开发者工具\n3、刷新页面，点击开发者工具中的网络(network)\u0026gt;过滤条件选择全部\u0026gt;选择下面任意一个请求并点击\n4、在请求头中找到Cookie，复制Cookie的值\n配置完成后点击保存\n配置下载器 1、点击左侧导航设定，下拉页面找到下载\n2、点击下载器模块中的+添加对应的下载器，没有的需要提前安装\n3、添加你下载器的地址、地址、用户名及密码\n4、点击保存\n配置刷流工具 1、依次点击左侧导航插件\u0026gt;插件市场\n2、点击站点刷流，系统会自动安装该插件，等待安装完成\n3、点击头部导航我的插件，点击站点刷流右下角的...\u0026gt;配置\n4、在配置页面中选择刚刚配置好的刷流站点，并选择对应的下载器\n5、左上角选择启用插件，点击保存\n好了，配置到这里，你现在可以自动进行刷流了\n","date":"2024-11-10T08:53:17Z","permalink":"https://tianhui.xin/p/moviepilot/","title":"moviepilot 刷流教程"},{"content":"在目前的部署模式下，通常会将Spring Boot项目部署在Kubernetes容器中； 今天，我们就来细说一下，如何使用Spring Boot Admin监控在Kubernetes上运行的Spring Boot应用程序。\nkubernetes下部署的架构往往是这样的： 服务employee-service部署在命名空间a中，department-service部署在命名空间b中，而organization-service部署在命名空间c中， Spring Boot Admin也使用Spring Boot启动，并默认部署在命名空间中。 此时，我们就可以通过kubernetes的Api对服务进行管理和监控。 PS：图是我抄的😜\n启动Spring Boot Admin Server 引入相关依赖 在SBA中，已经集成了kubernetes,如果需要通过kubernetes来发现服务，我们还需要把kubernetes-client包加入到项目中，SpringCloud已经为我们提供了spring-cloud-starter-kubernetes-client\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;utf-8\u0026#34; ?\u0026gt; \u0026lt;project\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;spring-boot.version\u0026gt;2.6.1\u0026lt;/spring-boot.version\u0026gt; \u0026lt;spring-cloud.version\u0026gt;2021.0.0\u0026lt;/spring-cloud.version\u0026gt; \u0026lt;!-- SBA 的最新版本 实际情况 和 spring boot 的版本号应该一致，目前没有发现不兼容的情况 --\u0026gt; \u0026lt;spring-boot-admin.version\u0026gt;2.5.5\u0026lt;/spring-boot-admin.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.codecentric\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-admin-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-boot-admin.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;${spring-cloud.version}\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.codecentric\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-admin-server-cloud\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;de.codecentric\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-admin-server-ui\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-kubernetes-client\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/project\u0026gt; 启动类配置 @EnableAdminServer 启用SBA Server服务 EnableDiscoveryClient 启用服务发现的能力 EnableScheduling 启用定时任务，这个很关键，不然你会发现启动的服务，无法在SBA中显示 1 2 3 4 5 6 7 8 9 @SpringBootApplication @EnableAdminServer // 启用 SBA Server 服务 @EnableDiscoveryClient // 启用服务发现 @EnableScheduling // 启用定时器 public class OpsAdminCloudServerApplication { public static void main(String[] args) { SpringApplication.run(OpsAdminCloudServerApplication.class, args); } } Spring Boot Admin Server 配置 既然我们使用kubernetes来发现服务，那么我们就需要对kubernetes的属性进行配置\nspring.cloud.kubernetes.discovery.service-labels 通过 Services 的 meta 中匹配对应的标记，不满足的则会被排除 spring.cloud.kubernetes.discovery.primary-port-name 当给 NodePort 指定多个多个端口时，通过name来确认使用哪个端口作为主端口 spring.cloud.kubernetes.client.namespace 指定服务所在的命名空间 spring.cloud.kubernetes.discovery.all-namespaces 当然，如果你不想指定命名空间，也可以设置该属性为true，程序会找到所有命名空间下满足service-labels的实例 spring.boot.admin.discovery.converter.management-context-path 如果实例的actuator地址被修改，需要配置该属性，默认值 /actuator； 该配置为全局配置，假设每个服务都有自己的context-path,需要编辑kubernetes文件，metadata.labels中配置management.context-path spring.boot.admin.discovery.converter.health-endpoint-path 如果实例的health地址被修改，需要配置该属性，默认值 /health； 该配置为全局配置，如果每个服务都有自己的健康检查,需要编辑kubernetes文件，metadata.labels中配置health.path 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 spring: cloud: kubernetes: discovery: service-labels: # 通过 Services 的 meta 中匹配对应的标记，不满足的则会被排除 spa-admin: enabled primary-port-name: http # nodePort 指定多个多个端口时，通过name来确认使用哪个端口请求 client: namespace: production # 指定命名空间 boot: application: name: spring-boot-admin-kubernetes # 服务名 admin: context-path: admin # Spring Boot Admin 的 页面或 api 的路径前缀 discovery: converter: management-context-path: /actuator # 访问实例 的 Spring Boot actuator 的根路径 health-endpoint-path: /health # 访问实例 健康检查的地址 实例配置 编写kubernetes文件 在metadata.labels属性下添加spa-admin: enabled，方便SPA过滤实例，对应SPA配置中的spring.cloud.kubernetes.discovery.service-labels 在spec.ports中配置端口信息，name的值为http，对应SPA配置中的spring.cloud.kubernetes.discovery.primary-port-name 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 kind: Service apiVersion: v1 metadata: name: admin-user-server namespace: production labels: name: sadmin-user-server app: admin-user-server version: production spa-admin: enabled spec: type: NodePort ports: - protocol: TCP name: http targetPort: 8080 port: 8080 nodePort: 32000 selector: app: admin-user-server 加入相关依赖 添加spring-boot-starter-actuator，给实例赋予actuator能力 通过spring-boot-maven-plugin插件，可以为actuator的info接口提供更多的信息 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;project \u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-actuator\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;executions\u0026gt; \u0026lt;execution\u0026gt; \u0026lt;goals\u0026gt; \u0026lt;goal\u0026gt;build-info\u0026lt;/goal\u0026gt; \u0026lt;/goals\u0026gt; \u0026lt;/execution\u0026gt; \u0026lt;/executions\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; 配置actuator 1 2 3 4 5 6 7 8 9 10 11 spring: application: name: admin-user-server management: endpoints: web: exposure: include: \u0026#34;*\u0026#34; endpoint: health: show-details: ALWAYS 效果图 写在最后 码字不易，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激\n","date":"2022-01-02T22:00:00Z","image":"https://image.tianhui.xin/spring/boot/admin/spring-boot-admin-on-kubernetes.png?x-oss-process=style/make","permalink":"https://tianhui.xin/p/spring-boot-admin-on-kubernetes/","title":"Spring Boot Admin On Kubernetes"},{"content":"@Conditional是Spring4新提供的注解，它的作用是按照一定条件进行判断，满足条件就将bean注册到容器。\nContidional 介绍 Conditional是由SpringFramework提供的一个注解，位于 org.springframework.context.annotation 包内，定义如下。\n1 2 3 4 5 6 7 @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.TYPE, ElementType.METHOD}) public @interface Conditional { Class\u0026lt;? extends Condition\u0026gt;[] value(); } 我们可以将 Spring 的@Conditional注解用于以下场景：\n可以作为类级别的注解直接或者间接的与@Component相关联，包括@Configuration类； 可以作为元注解，用于自动编写构造性注解； 作为方法级别的注解，作用在任何@Bean方法上。 Condition 接口 Condition 将在即将注册 Bean 定义之前进行检查，并且可以根据它的 matches() 方法返回值动态决定是否注册组件（true-允许注册；false-不允许注册）。\n1 2 3 public interface Condition { boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata); } 注意：Condition 必须遵循与 BeanFactoryPostProcessor 相同的限制，并注意永远不要与 bean 实例交互。对于与 @Configuration bean 交互的条件的更细粒度控制，请考虑实现 ConfigurationCondition 接口。\nContidional 申明 某个@Configuration注解的配置类上 某个@Configuration注解配置类中带有@Bean注解的方法上 任何用@Component、@Service、@Repository或@Controller注释声明的 Bean 1 2 3 4 5 @Configuration @Conditional(IsDevEnvCondition.class) class DevEnvLoggingConfiguration { // ... } 1 2 3 4 5 6 7 8 9 @Configuration class DevEnvLoggingConfiguration { @Bean @Conditional(IsDevEnvCondition.class) LoggingService loggingService() { return new LoggingService(); } } 1 2 3 4 5 @Service @Conditional(IsDevEnvCondition.class) class LoggingService { // ... } Contidional 实战 自定义条件 检查 Java 版本是否为 8\n1 2 3 4 5 6 class Java8Condition implements Condition { @Override public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) { return JavaVersion.getJavaVersion().equals(JavaVersion.EIGHT); } } 将 Java8Condition 作为 @Conditional 注释中的一个属性：\n1 2 3 4 5 @Service @Conditional(Java8Condition.class) public class Java8DependedService { // ... } 常见的条件注解 ConditionalOnProperty value属性，指定要检查的配置属性; haveValue属性，定义这个条件所需的值； matchIfMissing属性，如果缺少参数，是否应该匹配条件。 1 2 3 4 5 6 7 8 @Service @ConditionalOnProperty( value=\u0026#34;logging.enabled\u0026#34;, havingValue = \u0026#34;true\u0026#34;, matchIfMissing = true) class LoggingService { // ... } ConditionalOnExpression 相比较前面的Bean，Class是否存在，配置参数是否存在或者有某个值而言，这个依赖SPEL表达式的，就显得更加的高级了； 其主要就是执行Spel表达式，根据返回的true/false来判断是否满足条件\n1 2 3 4 5 6 7 @Service @ConditionalOnExpression( \u0026#34;${logging.enabled:true} and \u0026#39;${logging.level}\u0026#39;.equals(\u0026#39;DEBUG\u0026#39;)\u0026#34; ) class LoggingService { // ... } ConditionalOnBean 只有在容器中注册了某个bean,该条件才起作用\n1 2 3 4 5 @Service @ConditionalOnBean(CustomLoggingConfiguration.class) class LoggingService { // ... } Contidional 进阶 多重注解条件 此处demo实现满足某个环境变量时该条件才能生效\n创建注解类 Env\n1 2 3 4 5 6 @Target({ElementType.TYPE, ElementType.METHOD}) @Retention(RetentionPolicy.RUNTIME) @Documented public @interface Env { String[] value(); } 创建 Condition 实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public class EnvCondition implements Condition { @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata metadata) { // 查找@EnvCondition作用的方法或者类上的@Env注解 Map\u0026lt;String, Object\u0026gt; annotationAttributes = metadata.getAnnotationAttributes(Env.class.getName()); if (annotationAttributes != null) { String[] envList = (String[]) annotationAttributes.get(\u0026#34;value\u0026#34;); // 获取配置的环境变量，通过Java启动参数(vm options)配置 -Denv=dev String env = context.getEnvironment().getProperty(\u0026#34;env\u0026#34;); return Arrays.stream(envList).anyMatch(r -\u0026gt; Objects.equals(r, env)); } return false; } } 自定义条件使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class DemoConfiguration{ @Env(\u0026#34;dev\u0026#34;) @EnvCondition public EnvBean envBean(){ // ... } @Env(\u0026#34;prod\u0026#34;) @EnvCondition public EnvBean prodBean(){ // ... } } 写在最后 码字不易，因个人能力有限，难免有疏漏和错误之处，如发现bug或者有更好的建议，欢迎批评指正，不吝感激\n","date":"2021-09-16T18:30:52.905+08:00","permalink":"https://tianhui.xin/p/spring-conditional%E8%AF%A6%E8%A7%A3/","title":"Spring Conditional详解"},{"content":"开发过程中，你是否遇到需要对DB敏感数据进行加密，通常的做法是，存储的时候调用加密方法，查询的时候对结果进行解密， 嗯？这应该是一个痛苦的过程，好吧，今晚给大家安利一个强大的工具data-shield，针对mybatis架构，对数据在进行写入时加密，查询解密，为你的数据保驾护航, 我想你一定会爱上它\ndata-shield data-shield的实现采用mybatis的Interceptor实现，不仅实现的常规的查询和更新，也针对Cursor模式下的查询操作， 对业务代码无任何浸入性，只需要在需要加密的字段，添加一个注解，全程帮你完成数据的加密及解密操作，真是开发一大利器，话不多说， 进入今日的正题\npom.xml配置 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.github.homeant\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;data-shield-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-RELEASE\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; yaml配置 1 2 3 4 5 6 app: data: shield: enable: true strategy: aes #支持AES/DES模式 key: AD42F6697B035B7580E4FEF93BE20BAD 业务字段配置 为需要处理的业务字段添加@TableField注解,只支持String类型\nencrypt: 修改过程是否需要加密,默认为false\ndecode: 查询过程是否需要解密,默认为false\nasserts: decode为true时，针对某些数据(历史数据)提供断言,默认值DefaultAssert.class(encrypt=true,decode=true)\n1 2 3 4 5 6 7 8 9 @Data public class User { private Integer id; private String username; @TableField(encrypt = true,decode = true,assertion=Base64Assert.class) private String phone; } 代码调用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 public class Test{ @Autowired private UserMapper userMapper; @Autowired private SqlSessionFactory sqlSessionFactory; /** * RSA 加密模式会导致密文过长，不推荐使用 */ @Test public void test() { User user = new User(); user.setUsername(\u0026#34;tom\u0026#34;); user.setPassword(\u0026#34;p@ssw0rd1234567\u0026#34;); userMapper.insert(user); DataShieldHelper.dataMasking(); Optional\u0026lt;User\u0026gt; optional = userMapper.selectOn(user.getId()); DataShieldHelper.clearDataMasking(); optional.ifPresent(r -\u0026gt; { log.debug(\u0026#34;user:{}\u0026#34;, r); }); } @Test public void cursorTest() throws IOException { try (SqlSession sqlSession = sqlSessionFactory.openSession(); Cursor\u0026lt;User\u0026gt; userCursor = sqlSession.getMapper(UserMapper.class).selectList()) { Iterator\u0026lt;User\u0026gt; iterator = userCursor.iterator(); while (iterator.hasNext()){ log.info(\u0026#34;user:{}\u0026#34;,iterator.next()); } } } } 1 2 3 4 5 6 7 2021-04-03 16:23:16.604 DEBUG 3020 --- [ main] c.g.h.d.shield.mapper.UserMapper.insert : ==\u0026gt; Preparing: insert into t_user (username,password) values ( ?, ?) 2021-04-03 16:23:16.629 DEBUG 3020 --- [ main] c.g.h.d.shield.mapper.UserMapper.insert : ==\u0026gt; Parameters: tom(String), L0wfhbKDAELRnj03GtjKoQ==(String) 2021-04-03 16:23:16.651 DEBUG 3020 --- [ main] c.g.h.d.shield.mapper.UserMapper.insert : \u0026lt;== Updates: 1 2021-04-03 16:23:16.675 DEBUG 3020 --- [ main] c.g.h.d.s.mapper.UserMapper.selectOn : ==\u0026gt; Preparing: select id,username,password from t_user where id = ? 2021-04-03 16:23:16.675 DEBUG 3020 --- [ main] c.g.h.d.s.mapper.UserMapper.selectOn : ==\u0026gt; Parameters: 75(Integer) 2021-04-03 16:23:23.313 DEBUG 3020 --- [ main] c.g.h.d.s.mapper.UserMapper.selectOn : \u0026lt;== Total: 1 2021-04-03 16:23:26.166 DEBUG 3020 --- [ main] com.github.homeant.data.shield.DataTest : user:User(id=75, username=tom, password=p@ssw0rd1234567) 1 2 3 4 5 6 7 8 mysql\u0026gt; select * from t_user; +----+----------+--------------------------+ | id | username | password | +----+----------+--------------------------+ | 74 | tom | L0wfhbKDAELRnj03GtjKoQ== | | 75 | tom | L0wfhbKDAELRnj03GtjKoQ== | +----+----------+--------------------------+ 2 rows in set (0.03 sec) 代码地址\n","date":"2021-04-03T18:30:52.905+08:00","permalink":"https://tianhui.xin/p/mybatis%E5%AF%B9%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E5%8A%A0%E5%AF%86/","title":"mybatis对数据进行加密"},{"content":"在spring cloud体系中,有很多的注册中心和配置中心,比如最早的eureka以及consul、ZooKeeper,配置中心有 spring cloud config 及 携程的apollo config,今天我们要说的是阿里新秀Nacos来作为配置中心或者注册中心\nNacos是什么 Nacos is committed to help you discover, configure, and manage your microservices. It provides a set of simple and useful features enabling you to realize dynamic service discovery, service configuration, service metadata and traffic management.\nNacos makes it easier and faster to construct, deliver and manage your microservices platform. It is the infrastructure that supports a service-centered modern application architecture with a microservices or cloud-native approach.\nNacos 致力于帮助您发现、配置和管理微服务.Nacos 提供了一组简单易用的特性集,帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理.\nNacos 帮助您更敏捷和容易地构建、交付和管理微服务平台. Nacos 是构建以服务为中心的现代应用架构 (例如微服务范式、云原生范式) 的服务基础设施.\nNacos官网\n准备 安装Nacos server 下载地址\n动手能力强的小伙伴可以尝试自己编译,需要提前配置Java及Maven\n1 2 3 4 5 6 7 git clone https://github.com/alibaba/nacos.git cd nacos/ mvn -Prelease-nacos -Dmaven.test.skip=true clean install -U ls -al distribution/target/ // change the $version to your actual path cd distribution/target/nacos-server-$version/nacos/bin 启动Nacos server Linux/Unix/Mac 启动命令(standalone代表着单机模式运行,非集群模式):\n1 sh startup.sh -m standalone 如果您使用的是ubuntu系统,或者运行脚本报错提示[[符号找不到,可尝试如下运行：\n1 bash startup.sh -m standalone Windows 1 cmd startup.cmd 你也可以直接双击startup.cmd运行\n如何在spring cloud 中使用 作为配置中心使用 引入依赖 为了方便管理Spring cloud及nacos版本,可以提前在父级项目中配置dependencyManagement\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;dependencyManagement\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.8.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;Hoxton.SR6\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-alibaba-dependencies\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.2.1.RELEASE\u0026lt;/version\u0026gt; \u0026lt;type\u0026gt;pom\u0026lt;/type\u0026gt; \u0026lt;scope\u0026gt;import\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;/dependencyManagement\u0026gt; 1 2 3 4 5 6 7 8 9 10 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 配置nacos server application.yml中添加spring.application.name及spring.cloud.nacos.server-addr\n1 2 3 4 5 6 spring: application: name: spring-boot-nacos-config cloud: nacos: server-addr: localhost:127.0.0.1:8848 spring.application.name 是组成nacos 配置管理dataId字段的一部分 spring.cloud.nacos.server-addr nacos 的地址 完整的dataId在spring cloud nacos中为${prefix}-${spring.profile.active}.${file-extension} prefix 默认为 spring.application.name 的值,也可以通过配置项 spring.cloud.nacos.config.prefix来配置. spring.profile.active 即为当前环境对应的 profile,详情可以参考 Spring Boot文档. 注意：当 spring.profile.active 为空时,对应的连接符 - 也将不存在,dataId 的拼接格式变成 ${prefix}.${file-extension} file-exetension 为配置内容的数据格式,可以通过配置项 spring.cloud.nacos.config.file-extension 来配置.目前只支持 properties 和 yaml 类型,默认为properties 编写启动类 1 2 3 4 5 6 7 @SpringBootApplication public class NacosConfigApplication { public static void main(String[] args) { SpringApplication.run(NacosConfigApplication.class, args); } } 编写Controller 1 2 3 4 5 6 7 8 9 10 11 12 @RestController @RefreshScope public class IndexController { @Value(\u0026#34;${nacosConfig}\u0026#34;) private String nacosCongig; @GetMapping(\u0026#34;/config\u0026#34;) public String test(){ return nacosCongig; } } 添加配置 访问http://localhost:8848/nacos/ 用户名密码nacos 点击左侧菜单配置管理\u0026gt;配置列表,在右侧点击+添加配置 在输入页填写Data ID为我们配置的spring.application.name 配置格式选择为Properties,在配置内容添加nacosConfig=hello 如果Data ID填写错误,是无法获取到对应配置的\n添加完成后,返回到配置管理,可以看到我们刚刚添加的配置\n启动项目 访问http://localhost:8080/config,此时页面输出hello,那么恭喜你,大功告成.\n作为服务的注册中心使用 添加依赖 添加spring-cloud-starter-alibaba-nacos-discovery实现服务的注册和发现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-nacos-discovery\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 启动项目 此时,我们到nacos左侧菜单中点击服务管理\u0026gt;服务列表,可以看到我们刚刚启动的服务已经成功注册到了列表中\nNacos config 解读 那么,nacos是如何获取到配置在nacos server的配置的呢 查看源码我们可以看到在spring-cloud-starter-alibaba-nacos-config模块中,nacos添加了com.alibaba.cloud.nacos.NacosConfigBootstrapConfiguration的自启动, 其中NacosConfigProperties就是获取配置的关键,\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Configuration( proxyBeanMethods = false ) @ConditionalOnProperty( name = {\u0026#34;spring.cloud.nacos.config.enabled\u0026#34;}, matchIfMissing = true ) public class NacosConfigBootstrapConfiguration { public NacosConfigBootstrapConfiguration() { } @Bean @ConditionalOnMissingBean public NacosConfigProperties nacosConfigProperties() { return new NacosConfigProperties(); } @Bean @ConditionalOnMissingBean public NacosConfigManager nacosConfigManager(NacosConfigProperties nacosConfigProperties) { return new NacosConfigManager(nacosConfigProperties); } // 获取配置 实现org.springframework.cloud.bootstrap.config.PropertySourceLocator接口 @Bean public NacosPropertySourceLocator nacosPropertySourceLocator(NacosConfigManager nacosConfigManager) { return new NacosPropertySourceLocator(nacosConfigManager); } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 @Order(0) // 设置启动顺序 public class NacosPropertySourceLocator implements PropertySourceLocator { private static final Logger log = LoggerFactory.getLogger(NacosPropertySourceLocator.class); private static final String NACOS_PROPERTY_SOURCE_NAME = \u0026#34;NACOS\u0026#34;; private static final String SEP1 = \u0026#34;-\u0026#34;; private static final String DOT = \u0026#34;.\u0026#34;; private NacosPropertySourceBuilder nacosPropertySourceBuilder; private NacosConfigProperties nacosConfigProperties; private NacosConfigManager nacosConfigManager; /** @deprecated */ @Deprecated public NacosPropertySourceLocator(NacosConfigProperties nacosConfigProperties) { this.nacosConfigProperties = nacosConfigProperties; } public NacosPropertySourceLocator(NacosConfigManager nacosConfigManager) { this.nacosConfigManager = nacosConfigManager; this.nacosConfigProperties = nacosConfigManager.getNacosConfigProperties(); } // spring cloud 会执行此方法 public PropertySource\u0026lt;?\u0026gt; locate(Environment env) { this.nacosConfigProperties.setEnvironment(env); // 获取配置中心 ConfigService configService = this.nacosConfigManager.getConfigService(); if (null == configService) { log.warn(\u0026#34;no instance of config service found, can\u0026#39;t load config from nacos\u0026#34;); return null; } else { long timeout = (long)this.nacosConfigProperties.getTimeout(); // 获取配置的构造器 有 通过loadNacosData方法获取配置信息 this.nacosPropertySourceBuilder = new NacosPropertySourceBuilder(configService, timeout); String name = this.nacosConfigProperties.getName(); String dataIdPrefix = this.nacosConfigProperties.getPrefix(); // datdId 前缀,没有就用spring.application.name if (StringUtils.isEmpty(dataIdPrefix)) { dataIdPrefix = name; } if (StringUtils.isEmpty(dataIdPrefix)) { dataIdPrefix = env.getProperty(\u0026#34;spring.application.name\u0026#34;); } // 声明nacos配置来源 CompositePropertySource composite = new CompositePropertySource(\u0026#34;NACOS\u0026#34;); // 获取公共的配置 通过 spring.cloud.nacos.config.sharedConfigs 配置 this.loadSharedConfiguration(composite); // 获取扩展的配置 通过 spring.cloud.nacos.config.extensionConfigs 配置 this.loadExtConfiguration(composite); // 获取单前服务的配置 this.loadApplicationConfiguration(composite, dataIdPrefix, this.nacosConfigProperties, env); return composite; } } private void loadSharedConfiguration(CompositePropertySource compositePropertySource) { List\u0026lt;Config\u0026gt; sharedConfigs = this.nacosConfigProperties.getSharedConfigs(); if (!CollectionUtils.isEmpty(sharedConfigs)) { this.checkConfiguration(sharedConfigs, \u0026#34;shared-configs\u0026#34;); this.loadNacosConfiguration(compositePropertySource, sharedConfigs); } } private void loadExtConfiguration(CompositePropertySource compositePropertySource) { List\u0026lt;Config\u0026gt; extConfigs = this.nacosConfigProperties.getExtensionConfigs(); if (!CollectionUtils.isEmpty(extConfigs)) { this.checkConfiguration(extConfigs, \u0026#34;extension-configs\u0026#34;); this.loadNacosConfiguration(compositePropertySource, extConfigs); } } private void loadApplicationConfiguration(CompositePropertySource compositePropertySource, String dataIdPrefix, NacosConfigProperties properties, Environment environment) { // 获取配置类型 String fileExtension = properties.getFileExtension(); String nacosGroup = properties.getGroup(); this.loadNacosDataIfPresent(compositePropertySource, dataIdPrefix, nacosGroup, fileExtension, true); this.loadNacosDataIfPresent(compositePropertySource, dataIdPrefix + \u0026#34;.\u0026#34; + fileExtension, nacosGroup, fileExtension, true); String[] var7 = environment.getActiveProfiles(); int var8 = var7.length; for(int var9 = 0; var9 \u0026lt; var8; ++var9) { String profile = var7[var9]; String dataId = dataIdPrefix + \u0026#34;-\u0026#34; + profile + \u0026#34;.\u0026#34; + fileExtension; this.loadNacosDataIfPresent(compositePropertySource, dataId, nacosGroup, fileExtension, true); } } private void loadNacosConfiguration(final CompositePropertySource composite, List\u0026lt;Config\u0026gt; configs) { Iterator var3 = configs.iterator(); while(var3.hasNext()) { Config config = (Config)var3.next(); String dataId = config.getDataId(); String fileExtension = dataId.substring(dataId.lastIndexOf(\u0026#34;.\u0026#34;) + 1); this.loadNacosDataIfPresent(composite, dataId, config.getGroup(), fileExtension, config.isRefresh()); } } private void checkConfiguration(List\u0026lt;Config\u0026gt; configs, String tips) { String[] dataIds = new String[configs.size()]; for(int i = 0; i \u0026lt; configs.size(); ++i) { String dataId = ((Config)configs.get(i)).getDataId(); if (dataId == null || dataId.trim().length() == 0) { throw new IllegalStateException(String.format(\u0026#34;the [ spring.cloud.nacos.config.%s[%s] ] must give a dataId\u0026#34;, tips, i)); } dataIds[i] = dataId; } NacosDataParserHandler.getInstance().checkDataId(dataIds); } private void loadNacosDataIfPresent(final CompositePropertySource composite, final String dataId, final String group, String fileExtension, boolean isRefreshable) { if (null != dataId \u0026amp;\u0026amp; dataId.trim().length() \u0026gt;= 1) { if (null != group \u0026amp;\u0026amp; group.trim().length() \u0026gt;= 1) { NacosPropertySource propertySource = this.loadNacosPropertySource(dataId, group, fileExtension, isRefreshable); this.addFirstPropertySource(composite, propertySource, false); } } } // 获取配置,存在就直接取,不存在调用config server获取 关注 this.nacosPropertySourceBuilder.build private NacosPropertySource loadNacosPropertySource(final String dataId, final String group, String fileExtension, boolean isRefreshable) { return NacosContextRefresher.getRefreshCount() != 0L \u0026amp;\u0026amp; !isRefreshable ? NacosPropertySourceRepository.getNacosPropertySource(dataId, group) : this.nacosPropertySourceBuilder.build(dataId, group, fileExtension, isRefreshable); } private void addFirstPropertySource(final CompositePropertySource composite, NacosPropertySource nacosPropertySource, boolean ignoreEmpty) { if (null != nacosPropertySource \u0026amp;\u0026amp; null != composite) { if (!ignoreEmpty || !((Map)nacosPropertySource.getSource()).isEmpty()) { composite.addFirstPropertySource(nacosPropertySource); } } } public void setNacosConfigManager(NacosConfigManager nacosConfigManager) { this.nacosConfigManager = nacosConfigManager; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 public class NacosPropertySourceBuilder { private static final Logger log = LoggerFactory.getLogger(NacosPropertySourceBuilder.class); private static final Map\u0026lt;String, Object\u0026gt; EMPTY_MAP = new LinkedHashMap(); private ConfigService configService; private long timeout; public NacosPropertySourceBuilder(ConfigService configService, long timeout) { this.configService = configService; this.timeout = timeout; } public long getTimeout() { return this.timeout; } public void setTimeout(long timeout) { this.timeout = timeout; } public ConfigService getConfigService() { return this.configService; } public void setConfigService(ConfigService configService) { this.configService = configService; } NacosPropertySource build(String dataId, String group, String fileExtension, boolean isRefreshable) { Map\u0026lt;String, Object\u0026gt; p = this.loadNacosData(dataId, group, fileExtension); NacosPropertySource nacosPropertySource = new NacosPropertySource(group, dataId, p, new Date(), isRefreshable); NacosPropertySourceRepository.collectNacosPropertySource(nacosPropertySource); return nacosPropertySource; } // 获取配置 private Map\u0026lt;String, Object\u0026gt; loadNacosData(String dataId, String group, String fileExtension) { String data = null; try { // 请求config server 通过dataId和group获取配置 data = this.configService.getConfig(dataId, group, this.timeout); if (StringUtils.isEmpty(data)) { log.warn(\u0026#34;Ignore the empty nacos configuration and get it based on dataId[{}] \u0026amp; group[{}]\u0026#34;, dataId, group); return EMPTY_MAP; } if (log.isDebugEnabled()) { log.debug(String.format(\u0026#34;Loading nacos data, dataId: \u0026#39;%s\u0026#39;, group: \u0026#39;%s\u0026#39;, data: %s\u0026#34;, dataId, group, data)); } // 通过配置类型解析配置到map Map\u0026lt;String, Object\u0026gt; dataMap = NacosDataParserHandler.getInstance().parseNacosData(data, fileExtension); return dataMap == null ? EMPTY_MAP : dataMap; } catch (NacosException var6) { log.error(\u0026#34;get data from Nacos error,dataId:{}, \u0026#34;, dataId, var6); } catch (Exception var7) { log.error(\u0026#34;parse data from Nacos error,dataId:{},data:{},\u0026#34;, new Object[]{dataId, data, var7}); } return EMPTY_MAP; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 public class NacosConfigService implements ConfigService { private static final Logger LOGGER = LogUtils.logger(NacosConfigService.class); private static final long POST_TIMEOUT = 3000L; private static final String EMPTY = \u0026#34;\u0026#34;; private HttpAgent agent; private ClientWorker worker; private String namespace; private String encode; private ConfigFilterChainManager configFilterChainManager = new ConfigFilterChainManager(); // 获取配置 private String getConfigInner(String tenant, String dataId, String group, long timeoutMs) throws NacosException { group = this.null2defaultGroup(group); ParamUtils.checkKeyParam(dataId, group); ConfigResponse cr = new ConfigResponse(); cr.setDataId(dataId); cr.setTenant(tenant); cr.setGroup(group); // 获取本地文件中的配置 String content = LocalConfigInfoProcessor.getFailover(this.agent.getName(), dataId, group, tenant); if (content != null) { LOGGER.warn(\u0026#34;[{}] [get-config] get failover ok, dataId={}, group={}, tenant={}, config={}\u0026#34;, new Object[]{this.agent.getName(), dataId, group, tenant, ContentUtils.truncateContent(content)}); cr.setContent(content); this.configFilterChainManager.doFilter((IConfigRequest)null, cr); content = cr.getContent(); return content; } else { try { // ClientWorker 发送请求获取配置 String[] ct = this.worker.getServerConfig(dataId, group, tenant, timeoutMs); cr.setContent(ct[0]); this.configFilterChainManager.doFilter((IConfigRequest)null, cr); content = cr.getContent(); return content; } catch (NacosException var9) { if (403 == var9.getErrCode()) { throw var9; } else { LOGGER.warn(\u0026#34;[{}] [get-config] get from server error, dataId={}, group={}, tenant={}, msg={}\u0026#34;, new Object[]{this.agent.getName(), dataId, group, tenant, var9.toString()}); LOGGER.warn(\u0026#34;[{}] [get-config] get snapshot ok, dataId={}, group={}, tenant={}, config={}\u0026#34;, new Object[]{this.agent.getName(), dataId, group, tenant, ContentUtils.truncateContent(content)}); content = LocalConfigInfoProcessor.getSnapshot(this.agent.getName(), dataId, group, tenant); cr.setContent(content); this.configFilterChainManager.doFilter((IConfigRequest)null, cr); content = cr.getContent(); return content; } } } } } 获取配置关键\ncurl get http://config-server:{port}/v1/cs/configs?dataId={dataId}\u0026amp;group={group}\u0026amp;tenant={tenant}\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 public class ClientWorker { //tenant 默认为环境变量 tenant.id // 通过配置 nacos.use.cloud.namespace.parsing=true 如果teannt 为空取 acm.namespace // 通过配置 nacos.use.cloud.namespace.parsing=fase 如果teannt 为空取 ALIBABA_ALIWARE_NAMESPACE public String[] getServerConfig(String dataId, String group, String tenant, long readTimeout) throws NacosException { String[] ct = new String[2]; if (StringUtils.isBlank(group)) { group = \u0026#34;DEFAULT_GROUP\u0026#34;; } HttpResult result = null; try { List\u0026lt;String\u0026gt; params = null; if (StringUtils.isBlank(tenant)) { params = new ArrayList(Arrays.asList(\u0026#34;dataId\u0026#34;, dataId, \u0026#34;group\u0026#34;, group)); } else { params = new ArrayList(Arrays.asList(\u0026#34;dataId\u0026#34;, dataId, \u0026#34;group\u0026#34;, group, \u0026#34;tenant\u0026#34;, tenant)); } // curl get http://config-server:{port}/v1/cs/configs?dataId={dataId}\u0026amp;group={group}\u0026amp;tenant={tenant} result = this.agent.httpGet(\u0026#34;/v1/cs/configs\u0026#34;, (List)null, params, this.agent.getEncode(), readTimeout); } catch (IOException var10) { String message = String.format(\u0026#34;[%s] [sub-server] get server config exception, dataId=%s, group=%s, tenant=%s\u0026#34;, this.agent.getName(), dataId, group, tenant); LOGGER.error(message, var10); throw new NacosException(500, var10); } switch(result.code) { case 200: // 存储文件到本地缓存中 LocalConfigInfoProcessor.saveSnapshot(this.agent.getName(), dataId, group, tenant, result.content); ct[0] = result.content; if (result.headers.containsKey(\u0026#34;Config-Type\u0026#34;)) { ct[1] = (String)((List)result.headers.get(\u0026#34;Config-Type\u0026#34;)).get(0); } else { ct[1] = ConfigType.TEXT.getType(); } return ct; case 403: LOGGER.error(\u0026#34;[{}] [sub-server-error] no right, dataId={}, group={}, tenant={}\u0026#34;, new Object[]{this.agent.getName(), dataId, group, tenant}); throw new NacosException(result.code, result.content); case 404: LocalConfigInfoProcessor.saveSnapshot(this.agent.getName(), dataId, group, tenant, (String)null); return ct; case 409: LOGGER.error(\u0026#34;[{}] [sub-server-error] get server config being modified concurrently, dataId={}, group={}, tenant={}\u0026#34;, new Object[]{this.agent.getName(), dataId, group, tenant}); throw new NacosException(409, \u0026#34;data being modified, dataId=\u0026#34; + dataId + \u0026#34;,group=\u0026#34; + group + \u0026#34;,tenant=\u0026#34; + tenant); default: LOGGER.error(\u0026#34;[{}] [sub-server-error] dataId={}, group={}, tenant={}, code={}\u0026#34;, new Object[]{this.agent.getName(), dataId, group, tenant, result.code}); throw new NacosException(result.code, \u0026#34;http error, code=\u0026#34; + result.code + \u0026#34;,dataId=\u0026#34; + dataId + \u0026#34;,group=\u0026#34; + group + \u0026#34;,tenant=\u0026#34; + tenant); } } } 好啦,今天就说到这里,如有疑问可以评论区留言\n代码地址\n","date":"2020-06-27T12:30:52.905+08:00","image":"https://image.tianhui.xin/spring-cloud/nacos.png?x-oss-process=style/make","permalink":"https://tianhui.xin/p/%E8%B7%9F%E6%88%91%E5%AD%A6springcloud-%E4%B9%8B-nacos/","title":"跟我学SpringCloud 之 nacos"},{"content":"在开发过程中总会遇到Java对象相互转换,出了最原始及最高效的get/set一块,Java平台中,也出现了很多对象转换工具.\n今天本是父亲节,也是地球百年罕见的一次日食现象,晨到点就抱着相机出门,结果专业度不够,拍了俩月亮回来; 朋友圈也是晒疯了,各种各样的太阳,对都是你们的太阳; 此时的我回到家中,左思右想,这个周末又要颓废了吗,别介,好记性不如烂笔头,写会文章吧；(TM\u0026hellip;.一堆废话)\n好吧,咱进入今天的正题,Java对象转换工具哪家强？ 首先,java平台中提供了很多的转换工具,旨在提供工作效率,我给大家列举一下\nBeanUtils\nDozer\nOrika\nMapStruct\nModelMapper\nJMapper\n此处排名不分先后,专业评测\n什么是MapStruct MapStruct is a code generator that greatly simplifies the implementation of mappings between Java bean types based on a convention over configuration approach. The generated mapping code uses plain method invocations and thus is fast, type-safe and easy to understand.\n啥意思？官方说它是个代码生成器,生成约定的Java bean对象转换.重点是纯方法调用\n纯方法调用容我先买个关子,5毛,不能再多了.\n还记得最初的BeanUtils吗,对于同属性copy,当年用的贼嗨,慢慢的工作经验和程序的并发出现,发现效率并没有那么高;\n还有非同属性copy,中途换了N多,比如居于配置文件的Dozer,写着复杂的xml配置.这些框架的背后无不使用了Java的反射或者代理;\n此时,要说今天的主角之前,我觉得咱又必须要先说一下,大名鼎鼎的lombok,很多人都耳目共染,有了它,我们再也不用写get/set了,好嗨呀!!!\n那么MapStruct又能让我们少写什么呢,对,这位同学很聪慧,不需要我们写对象转换时的get/set啦.\nMapStruct亮点是啥 Multi-layered applications often require to map between different object models (e.g. entities and DTOs). Writing such mapping code is a tedious and error-prone task. MapStruct aims at simplifying this work by automating it as much as possible.\nIn contrast to other mapping frameworks MapStruct generates bean mappings at compile-time which ensures a high performance, allows for fast developer feedback and thorough error checking.\n翻译就算了,直接说重点,Java bean 属性转换,这样的代码写多了,看着冗余,还不好找(密密麻麻),MapStruct在编译的时候,帮你生成对应的映射关系,提供开发效率.\n如何使用 导入对应依赖 1.3.1.Final的mapstruct-jdk8已经指向mapstruct,所以导入mapstruct-jdk8已经成为过去式\n1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.1.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.mapstruct\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mapstruct-processor\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.3.1.Final\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; mapstruct 含有对应的注解,比如@Mapper mapstruct-processor 包含Java处理机制,代码生成的关键 编写Java Bean 1 2 3 4 5 6 @Data public class User implements Serializable { private String loginName; private String password; } 1 2 3 4 5 6 @Data public class UserDto implements Serializable { private String username; private String password; } 编写Mapper 1 2 3 4 5 6 7 @Mapper(componentModel = \u0026#34;spring\u0026#34;) public interface UserMapper { UserMapper INSTANCE = Mappers.getMapper(UserMapper.class); @Mapping(source = \u0026#34;loginName\u0026#34;, target = \u0026#34;username\u0026#34;) UserDto userToUserDto(User user); } @Mapper(componentModel = \u0026quot;spring\u0026quot;)使用spring方式注入 UserMapper INSTANCE = Mappers.getMapper(UserMapper.class); 不使用spring注入时,可以使用实例模式,默认 @Mapping(source = \u0026quot;loginName\u0026quot;, target = \u0026quot;username\u0026quot;) 约定映射关系,多个使用@Mappings 测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 @Slf4j public class DomainTest extends ApplicationTest { @Autowired private UserMapper userMapper; @Test public void test(){ User user = new User(); user.setLoginName(\u0026#34;12321\u0026#34;); user.setPassword(\u0026#34;123456\u0026#34;); // 实例模式 log.info(\u0026#34;result:{}\u0026#34;,UserMapper.INSTANCE.userToUserDto(user)); } @Test public void test2(){ User user = new User(); user.setLoginName(\u0026#34;12321\u0026#34;); user.setPassword(\u0026#34;123456\u0026#34;); // spring 注入模式 log.info(\u0026#34;result:{}\u0026#34;,userMapper.userToUserDto(user)); } } 原理 上文讲述了如何使用MapStruct,现在我们来讲述下原理,讲述原理前,我们要知道一个大杀器\nAnnotation Processor Annotation Processor注解处理器是javac内置的一个用于编译时扫描和处理注解(Annotation)的工具. 简单的说,在源代码编译阶段,通过注解处理器,我们可以获取源文件内注解(Annotation)相关内容.\n编译时注解处理器AnnotationProcessor的使用\n查看lombok和MapStruct源码,我们都发现有这样一个文件\nMETA-INF/services/javax.annotation.processing.Processor\n内容大概是这样的,它在告诉javac对应的注解处理是哪些\n1 2 3 4 5 # Copyright MapStruct Authors. # # Licensed under the Apache License version 2.0, available at http://www.apache.org/licenses/LICENSE-2.0 org.mapstruct.ap.MappingProcessor 通过MappingProcessor一系列的处理后,MapStruct为你生成了对应的mapper的实现类,我们来看看生成的代码怎样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 @Component public class UserMapperImpl implements UserMapper { public UserMapperImpl() { } public UserDto userToUserDto(User user) { if (user == null) { return null; } else { UserDto userDto = new UserDto(); userDto.setUsername(user.getLoginName()); userDto.setPassword(user.getPassword()); return userDto; } } } 此时,是不是觉得哪些代理、反射都弱爆了,对此你有什么样的看法呢,欢迎留言,我们一起探讨\n","date":"2020-06-21T18:22:52.905+08:00","image":"https://image.tianhui.xin/mapstruct/Mapstruct.png?x-oss-process=style/make","permalink":"https://tianhui.xin/p/%E4%B8%80%E8%A7%81%E5%80%BE%E5%BF%83%E4%B9%8B%E5%88%9D%E9%81%87mapstruct/","title":"一见倾心之初遇MapStruct"},{"content":"拦截器的一个作用就是我们可以拦截某些方法的调用，我们可以选择在这些被拦截的方法执行前后加上某些逻辑。 那么如果使用Mybatis对数据进行拦截，做一些满足自己需求的东西呢。今天我们就用这个实现一个数据的脱敏功能。\nInterceptor接口 对于拦截器Mybatis为我们提供了一个Interceptor接口，通过实现该接口就可以定义我们自己的拦截器。首先我们先来看一下这个接口的定义：\n1 2 3 4 5 6 7 8 9 10 11 12 13 package org.apache.ibatis.plugin; import java.util.Properties; public interface Interceptor { Object intercept(Invocation invocation) throws Throwable; Object plugin(Object target); void setProperties(Properties properties); } 可以看到，需要我们实现的方法有：\nintercept拦截器的处理逻辑 plugin拦截器用于封装目标对象的，通过该方法我们可以返回目标对象本身，也可以返回一个它的代理。 setProperties为插件设置properties属性\n需求实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @Intercepts({ @Signature( type = ResultSetHandler.class, method = \u0026#34;handleResultSets\u0026#34;, args = {Statement.class} ) }) public class DataMaskingInterceptor implements Interceptor { @Override public Object intercept(Invocation invocation) throws Throwable { // 获取到返回结果 Object returnValue = invocation.proceed(); if (returnValue != null) { // 对结果进行处理 if (returnValue instanceof ArrayList\u0026lt;?\u0026gt;) { List\u0026lt;?\u0026gt; list = (ArrayList\u0026lt;?\u0026gt;) returnValue; for (int index = 0; index \u0026lt; list.size(); index++) { Object returnItem = list.get(index); if (returnItem != null) { Class\u0026lt;?\u0026gt; clazz = returnItem.getClass(); Type superType = clazz.getGenericSuperclass(); if (superType.getClass().isInstance(Object.class)) { List\u0026lt;Field\u0026gt; fieldList = new ArrayList\u0026lt;\u0026gt;(); // 利用反射获取所有字段 ReflectionUtils.doWithFields(clazz, fieldList::add); for (Field field : fieldList) { // 获取结果类上的注解 TableField annotation = field.getAnnotation(TableField.class); if (annotation != null) { // 获取是否登记了脱敏 为什么要使用登记，而不使用注解呢？ String dataMaskingFlag = DataShieldHelper.getDataMasking(); if (!StringUtils.isEmpty(dataMaskingFlag)) { Class\u0026lt;? extends DataMasking\u0026gt; dataMasking = annotation.dataMasking(); if (dataMasking != DataMasking.class) { DataMasking instance = getInstance(dataMasking); field.setAccessible(true); String value = (String) field.get(returnItem); value = instance.apply(value); ReflectionUtils.setField(field, returnItem, value); } } } } } } } } } return returnValue; } /** /* 固定写法 原理见 org.apache.ibatis.plugin.Plugin.wrap 方法 **/ @Override public Object plugin(Object target) { return Plugin.wrap(target, this); } @Override public void setProperties(Properties properties) { } private \u0026lt;T\u0026gt; T getInstance(Class\u0026lt;T\u0026gt; clazz) throws IllegalAccessException, InstantiationException { return clazz.newInstance(); } } 解释代码中为啥要使用DataShieldHelper来实现脱敏登记，我们在项目开发过程中，经常会用到Java对象复用的情况，那么如果在某个字段上加上脱敏注解，会出现实现问题，我们不能对拦截器去判断哪些查询需要脱敏哪些不需要，那么怎么才能实现需要时才对数据进行脱敏，某些情况不需要呢，此时ThreadLocal就能帮助到我们，ThreadLocal提供了线程内存储变量的能力，这些变量不同之处在于每一个线程读取的变量是对应的互相独立的。通过get和set方法就可以得到当前线程对应的值。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 /** /* 线程工具类 主要用于登记脱敏操作 **/ public class DataShieldHelper { private static final ThreadLocal\u0026lt;String\u0026gt; LOCAL_DATA_MASKING = new ThreadLocal(); public static void dataMasking(String symbol){ if(symbol==null || symbol.isEmpty()){ symbol = \u0026#34;*\u0026#34;; } LOCAL_DATA_MASKING.set(symbol); } public static void dataMasking(){ dataMasking(\u0026#34;*\u0026#34;); } public static String getDataMasking(){ return LOCAL_DATA_MASKING.get(); } public static void clearDataMasking(){ LOCAL_DATA_MASKING.remove(); } } 使用@Intercepts 拦截ResultSetHandler接口中参数类型为Statement的handleResultSets方法 ResultSetHandler 主要负责将JDBC返回的ResultSet结果集对象转换成List类型的集合\n拦截器的注册 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34; ?\u0026gt; \u0026lt;!DOCTYPE configuration PUBLIC \u0026#34;-//mybatis.org//DTD Config 3.0//EN\u0026#34; \u0026#34;http://mybatis.org/dtd/mybatis-3-config.dtd\u0026#34;\u0026gt; \u0026lt;configuration\u0026gt; \u0026lt;properties resource=\u0026#34;config/jdbc.properties\u0026#34;\u0026gt;\u0026lt;/properties\u0026gt; \u0026lt;typeAliases\u0026gt; \u0026lt;package name=\u0026#34;com.github.homeant.model\u0026#34; /\u0026gt; \u0026lt;/typeAliases\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin interceptor=\u0026#34;com.github.homeant.mybatis.interceptor.DataMaskingInterceptor\u0026#34;\u0026gt; \u0026lt;!-- 属性 --\u0026gt; \u0026lt;property name=\u0026#34;prop1\u0026#34; value=\u0026#34;prop1\u0026#34; /\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;environments default=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;environment id=\u0026#34;development\u0026#34;\u0026gt; \u0026lt;transactionManager type=\u0026#34;JDBC\u0026#34; /\u0026gt; \u0026lt;dataSource type=\u0026#34;POOLED\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;driver\u0026#34; value=\u0026#34;${jdbc.driver}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;url\u0026#34; value=\u0026#34;${jdbc.url}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;username\u0026#34; value=\u0026#34;${jdbc.username}\u0026#34; /\u0026gt; \u0026lt;property name=\u0026#34;password\u0026#34; value=\u0026#34;${jdbc.password}\u0026#34; /\u0026gt; \u0026lt;/dataSource\u0026gt; \u0026lt;/environment\u0026gt; \u0026lt;/environments\u0026gt; \u0026lt;mappers\u0026gt; \u0026lt;mapper resource=\u0026#34;com/github/homeant/mapper/UserMapper.xml\u0026#34; /\u0026gt; \u0026lt;/mappers\u0026gt; \u0026lt;/configuration\u0026gt; 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 public class Test{ @Test public void test(){ // 脱敏登记 DataShieldHelper.dataMasking(); Optional\u0026lt;User\u0026gt; optional = userMapper.selectOn(user.getId()); // 取消 DataShieldHelper.clearDataMasking(); optional.ifPresent(r-\u0026gt;{ log.debug(\u0026#34;user:{}\u0026#34;,r); }); } } 效果 可以看到，我们查询出来的数据已经脱敏了\n1 2 3 4 2020-06-01 23:34:11.910 DEBUG 34392 --- [ main] c.g.h.d.s.mapper.UserMapper.selectOn : ==\u0026gt; Preparing: select id,username,password from t_user where id = ? 2020-06-01 23:34:11.910 DEBUG 34392 --- [ main] c.g.h.d.s.mapper.UserMapper.selectOn : ==\u0026gt; Parameters: 71(Integer) 2020-06-01 23:34:11.930 DEBUG 34392 --- [ main] c.g.h.d.s.mapper.UserMapper.selectOn : \u0026lt;== Total: 1 2020-06-01 23:34:11.940 DEBUG 34392 --- [ main] com.github.homeant.data.shield.DataTest : user:User(id=71, username=tom, password=p@***********67) 上述为简易版代码，如果需要，请前往GitHub进行下载\n代码直通车 data-shield\n","date":"2020-05-31T10:03:17Z","permalink":"https://tianhui.xin/p/mybatis-interceptor-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E8%84%B1%E6%95%8F/","title":"Mybatis Interceptor 实现数据脱敏"},{"content":"为了防止分布式系统中的多个进程之间相互干扰，我们需要一种分布式协调技术来对这些进程进行调度。 那么如何在Java 1.8中写出优雅的分布式锁，此篇文章为你讲解。\n加锁 redis提供 setnx 命令命令。key 是锁的唯一标识，可以按业务来决定命名。当一个线程第一次执行时，返回1标识加锁成功，此时第二个线程开始执行，返回0标识加锁识别，已经有程序在处理。\n1 setnx(\u0026#39;key\u0026#39;,\u0026#39;value\u0026#39;); # set if not exits 释放锁 那么，锁加上了，怎么释放锁呢，代码也非常的简单，使用del就可以释放锁。\n1 del(\u0026#39;key\u0026#39;); # 删除Redis中的缓存 锁超时 在系统中总会存在一种情况，在加锁的途中，处理业务场景失败，没来得及释放锁，那么下一次业务将无法正常处理，这时咱们就需要使用第三个函数来自动释放锁。\n1 expire(\u0026#39;key\u0026#39;,millisecond); # 为缓存设置过期时间 存在问题 了解redis的大佬们都知道，redis命令是一个命令一次连接，如果在加锁的过程中，加锁成功，紧接着redis节点宕机了，程序处理又没来得起其实释放锁，那么还是出现了上述死锁的问题，虽然这种情况很少发生，但也存在隐患。\n1 set(\u0026#39;key\u0026#39;,\u0026#39;value\u0026#39;,millisecond,\u0026#39;NX\u0026#39;); # NX SET IF NOT EXIST JAVA实现 了解几个常用命令，那么我们来在Java代码中实现\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 @Slf4j @Component public class BusinessLockComponent{ @Autowired private RedisTemplate redisTemplate; private final static String JSON_STRING = \u0026#34;{\\\u0026#34;key\\\u0026#34;:\\\u0026#34;%s\\\u0026#34;,\\\u0026#34;result\\\u0026#34;:%b,\\\u0026#34;time\\\u0026#34;:%d}\u0026#34;; /** * 为每个业务加锁 * * @param lockKey * @param time * @param callback */ public void lock(String lockKey, Long time, LockCallback callback) { Boolean flag = lock(lockKey, time); log.info(\u0026#34;BUSINESS_LOCK|{}\u0026#34;, String.format(JSON_STRING, lockKey, flag, time)); try { if (flag) { callback.execute(); } } finally { deleteLook(lockKey); } } private Boolean lock(String lockKey, Long time) { return (Boolean) redisTemplate.execute((RedisCallback) connection -\u0026gt; { long expireAt = System.currentTimeMillis() + time + 1; Boolean acquire = connection.setNX(lockKey.getBytes(), String.valueOf(expireAt).getBytes()); if (acquire) { return true; } else { byte[] value = connection.get(lockKey.getBytes()); if (Objects.nonNull(value) \u0026amp;\u0026amp; value.length \u0026gt; 0) { long expireTime = Long.parseLong(new String(value)); // 如果锁已经过期 if (expireTime \u0026lt; System.currentTimeMillis()) { // 重新加锁，防止死锁 byte[] oldValue = connection.getSet(lockKey.getBytes(), String.valueOf(System.currentTimeMillis() + time + 1).getBytes()); return Long.parseLong(new String(oldValue)) \u0026lt; System.currentTimeMillis(); } } } return false; }); } private void deleteLook(String lockKey) { redisTemplate.delete(lockKey); } } 加锁成功执行函数 1 2 3 4 5 6 7 8 9 10 11 /** * 锁回调方法 * */ public interface LockCallback { /** * 执行方法 */ @NonNull void execute(); } 使用 1 2 3 4 5 6 7 8 9 10 public class Test{ @Autowired private BusinessLockComponent lockComponent; public void methodX(){ lockComponent.lock(\u0026#34;20200404\u0026#34;,System.currentTimeMillis()+5000,()-\u0026gt;{ System.out.println(\u0026#34;武汉加油\u0026#34;); }); } } 使用spring integeration 实现分布式锁 其实Spring早期就实现了，存在于Spring Cloud Cluster项目中，后期发展，迁移到了Spring Integration中，实现方式如下：\n加入依赖 1 2 3 4 5 6 7 8 9 10 11 12 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-integration\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.integration\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-integration-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-data-redis\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 添加配置 在application.yml中添加\n1 2 3 4 spring: redis: port: 6379 host: localhost 配置bean 1 2 3 4 5 6 7 8 9 @Configuration public class RedisLockConfiguration { @Bean public RedisLockRegistry redisLockRegistry(RedisConnectionFactory redisConnectionFactory) { return new RedisLockRegistry(redisConnectionFactory, \u0026#34;spring-cloud\u0026#34;); } } 使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 @RestController @RequestMapping(\u0026#34;redis\u0026#34;) public class IndexController { @Autowired private RedisLockRegistry redisLockRegistry; @GetMapping(\u0026#34;/test\u0026#34;) public void test(){ Lock lock = redisLockRegistry.obtain(\u0026#34;lock\u0026#34;); boolean isLock = lock.tryLock(1, TimeUnit.SECONDS); if(isLock){ System.out.println(s + \u0026#34;取锁锁了\u0026#34;); lock.unlock(); } } } 今天就写到这里，下次见，码字不易，有问题请留言交流。\n","date":"2020-04-04T12:34:17Z","permalink":"https://tianhui.xin/p/%E4%BC%98%E9%9B%85%E7%9A%84%E4%BD%BF%E7%94%A8java%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","title":"优雅的使用Java分布式锁"},{"content":"继上次分享的GitHub actions 发布到GitHub pages,收到的反馈还不错，咱们这次也记录了下编写脚本的过程，过程比较坎坷，如果只要结果，请看文章最后几个板块的内容。\n准备工作 SSH key 生成 1 2 3 4 ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key) 配置私钥 如果前面读过我的hugo通过Github Action部署到Github Pages文章，那么一定知道怎么去上传公钥，这里我们再重复一下\n假设 开发项目为 tianhui.xin\n打开tianhui.xin仓库的settings，再点击Secrets，然后添加咱们刚刚生成的私钥，name为ACTIONS_DEPLOY_KEY\nAdd your private key Success 上传公钥服务器 1 2 3 4 5 6 ssh-copy-id appuser@10.10.10.10 /usr/bin/ssh-copy-id: INFO: Source of key(s) to be installed: \u0026#34;/home/appuser/.ssh/id_rsa.pub\u0026#34; The authenticity of host \u0026#39;10.10.10.10 (10.10.10.10)\u0026#39; can\u0026#39;t be established. ECDSA key fingerprint is SHA256:mpM5LP8zLMh/CibV34URdTFbciAJ3fvCG1f9kSD2ITI. ECDSA key fingerprint is MD5:60:40:77:02:5b:c6:e0:9a:e7:a3:96:bf:10:da:12:1c. Are you sure you want to continue connecting (yes/no)? yes 输入远程用户的密码后，SSH公钥就会自动上传了．SSH公钥保存在远程Linux服务器的.ssh/authorized_keys文件中\n思考 docker镜像每次都是一个新的，SSH在第一次连接都会询问这个一个问题\n1 2 3 4 5 6 7 The authenticity of host \u0026#39;10.10.10.10 (10.10.10.10)\u0026#39; can\u0026#39;t be established. RSA key fingerprint is 97:8c:1b:f2:6f:14:6b:5c:3b:ec:aa:46:46:74:7c:40. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added \u0026#39;10.10.10.10 (10.10.10.10)\u0026#39; (RSA) to the list of known hosts. Enter passphrase for key \u0026#39;/home/appuser/.ssh/id_rsa\u0026#39;: 其原因是因为/home/appuser/.ssh目录下的known_hosts不存在对你正要连接的服务器信息，也就是说你是第一次连接；那么我们是不是可以伪造一个呢，喏，你还别说，我还真去把自己电脑上的known_hosts的对应记录复制了一份上去，我简直是个天才，但结果不尽人意，好吧，咱们继续折腾。\n幸运的是我在梯子的帮助下，找到了这样一个命令ssh-keyscan，搞起🤕\n1 ssh-keyscan -t rsa 10.10.10.10 \u0026gt;\u0026gt; \u0026#34;/home/appuser/known_hosts\u0026#34; 新建job脚本(测试SSH脚本) 主要过程就是测试下在docker环境下如何远程SSH，\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 name: aliyun on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@master with: submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2.2.2 with: hugo-version: \u0026#39;0.59.1\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy env: ACTIONS_DEPLOY_KEY: ${{ secrets.ACTIONS_DEPLOY_KEY }} HOST: 10.10.10.10 USER: appuser run: | SSH_PATH=\u0026#34;$HOME/.ssh\u0026#34; mkdir -p $SSH_PATH touch \u0026#34;$SSH_PATH/known_hosts\u0026#34; echo \u0026#34;$ACTIONS_DEPLOY_KEY\u0026#34; \u0026gt; \u0026#34;$SSH_PATH/id_rsa\u0026#34; chmod 700 \u0026#34;$SSH_PATH\u0026#34; chmod 600 \u0026#34;$SSH_PATH/known_hosts\u0026#34; chmod 600 \u0026#34;$SSH_PATH/id_rsa\u0026#34; eval $(ssh-agent) ssh-add \u0026#34;$SSH_PATH/id_rsa\u0026#34; ssh-keyscan -t rsa $HOST \u0026gt;\u0026gt; \u0026#34;$SSH_PATH/known_hosts\u0026#34; ssh -o StrictHostKeyChecking=no -i $SSH_PATH/id_rsa -A -tt $USER@$HOST ls 执行push，等待CI部署完成，查看log发现已经打印出了服务器的文件文件夹信息，😄\n最终的job脚本 配置说明 使用只需要关注deploy中的env配置\nconfig description ACTIONS_DEPLOY_KEY 连接服务的私钥(在GitHub项目下的setting\u0026gt;Secrets配置) HOST 服务器的IP地址 USER 服务器的部署用户，对应的私钥的用户 HOME_PATH 登陆服务器后，我们去哪个目录，一般设置为用户目录 DEVELOP_SH_PATH 服务器部署脚本(咱们的部署目录还是服务器上执行，不写在job中) PACKAGE_NAME 打包的名称(public.tar.gz),目前只支持这个 DEVELOP_DIR 项目部署文件夹 BACKUP_DIR 项目的备份文件夹 job文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 name: aliyun on: push: branches: - master jobs: build: runs-on: ubuntu-latest steps: - name: checkout uses: actions/checkout@master with: submodules: true - name: setup Hugo uses: peaceiris/actions-hugo@v2.2.2 with: hugo-version: \u0026#39;0.59.1\u0026#39; extended: true - name: Build run: hugo --minify - name: deploy env: ACTIONS_DEPLOY_KEY: ${{ secrets.ACTIONS_DEPLOY_KEY }} HOST: 10.10.10.10 USER: appuser HOME_PATH: /home/appuser DEVELOP_SH_PATH: /home/appuser/develop.sh PACKAGE_NAME: public.tar.gz DEVELOP_DIR: tianhui.xin BACKUP_DIR: backup run: | SSH_PATH=\u0026#34;$HOME/.ssh\u0026#34; mkdir -p $SSH_PATH touch \u0026#34;$SSH_PATH/known_hosts\u0026#34; echo \u0026#34;$ACTIONS_DEPLOY_KEY\u0026#34; \u0026gt; \u0026#34;$SSH_PATH/id_rsa\u0026#34; chmod 700 \u0026#34;$SSH_PATH\u0026#34; chmod 600 \u0026#34;$SSH_PATH/known_hosts\u0026#34; chmod 600 \u0026#34;$SSH_PATH/id_rsa\u0026#34; eval $(ssh-agent) ssh-add \u0026#34;$SSH_PATH/id_rsa\u0026#34; ssh-keyscan -t rsa $HOST \u0026gt;\u0026gt; \u0026#34;$SSH_PATH/known_hosts\u0026#34; cd public tar -cf $PACKAGE_NAME * scp $PACKAGE_NAME $USER@$HOST:$HOME_PATH ssh -o StrictHostKeyChecking=no -i $SSH_PATH/id_rsa -A -tt $USER@$HOST sh $DEVELOP_SH_PATH \\ -d $HOME_PATH/$DEVELOP_DIR -b $HOME_PATH/$BACKUP_DIR -f $HOME_PATH/$PACKAGE_NAME exit 远程服务器操作 新建develop.sh 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #!/bin/sh set -e FILE_NAME=`basename $0` #说明 show_usage=\u0026#34;usage:$FILE_NAME [-d develop_path,-b backup_path -f file_path]\u0026#34; #参数 # 本地仓库目录 opt_develop_path=\u0026#34;\u0026#34; # 备份目录 opt_backup_path=\u0026#34;\u0026#34; # 部署文件 opt_file_path=\u0026#34;\u0026#34; GETOPT_ARGS=`getopt -o d:b:f: -al develop_path:,backup_path:,file_path: -- \u0026#34;$@\u0026#34;` eval set -- \u0026#34;$GETOPT_ARGS\u0026#34; #获取参数 while [ -n \u0026#34;$1\u0026#34; ] do case \u0026#34;$1\u0026#34; in -d|--develop_path) opt_develop_path=$2; shift 2;; -b|--backup_path) opt_backup_path=$2; shift 2;; -f|--opt_file_path) opt_file_path=$2; shift 2;; --) break ;; *) echo $1,$2,$show_usage; break ;; esac done # 判断参数 if [[ -z $opt_develop_path || -z $opt_backup_path || -z $opt_file_path ]]; then echo -e $show_usage exit 0 fi if [ \u0026#34;$opt_develop_path\u0026#34; = \u0026#34;$opt_backup_path\u0026#34; ]; then echo \u0026#39;develop_path eq backup_path\u0026#39; exit 0 fi # 判断部署文件是否存在 if [ ! -f $opt_file_path ]; then echo \u0026#34;$opt_file_path file does not exist\u0026#34; exit 0 fi # 判断文件夹是否存在 if [ ! -x $opt_develop_path ]; then mkdir $opt_develop_path fi # 判断文件夹是否存在 if [ ! -x $opt_backup_path ]; then mkdir $opt_backup_path fi # 文件夹不是空的 if [ ! \u0026#34;`ls -A $opt_develop_path`\u0026#34; = \u0026#34;\u0026#34; ]; then cd $opt_develop_path tar -cf $opt_backup_path/$(date +%Y%m%d%H%M).tar.gz $opt_develop_path/* rm -rf $opt_develop_path/* fi # 解压文件 tar -xf $opt_file_path -C $opt_develop_path echo \u0026#34;publish success!\u0026#34; 给予执行权限 1 chomd u+x develop.sh 一切准备就绪，开始你的奇妙之旅吧，码字不易，有问题请留言交流。\n相关文章:\nhugo通过Github Action部署到Github Pages ","date":"2019-11-29T03:00:00Z","permalink":"https://tianhui.xin/p/%E9%80%9A%E8%BF%87github-actions%E5%8F%91%E5%B8%83hugo%E5%88%B0%E7%A7%81%E6%9C%89%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/","title":"通过GitHub actions发布hugo到私有云服务器"},{"content":"最近一段时间，把博客从hexo迁移到了hugo,顺便整理下，使用github actions自动部署到github pages。\n编写脚本 首先打开自己项目中的Actions,进入之后，它有很多的自动化部署工具，我们选择Simple workflow 选择后，会出现一个yml文件的编辑器，里面的内容是这样的: 1 2 3 4 5 6 7 8 9 10 11 12 13 name: CI on: [push] jobs: build: runs-on: ubuntu-latest steps: - uses: actions/checkout@v1 - name: Run a one-line script run: echo Hello, world! - name: Run a multi-line script run: | echo Add other actions to build, echo test, and deploy your project. 我们结合上图，说下标注的地方，也是github的一个亮点吧，在编辑器中，他们我们的yam文件进行了语法的校验，同时也做些key的校验，比如存在users的时候，就不能出现run,我个人理解，users本身就是一个动作，所以无法再去执行其他命令；然后模板市场，里面有很多开发语言的部署脚本，都是大牛们封装好的，找到符合自身项目的直接使用就行。\n调整yml文件内容\n因为使用的hugo的博客，所以官方是提供的自动化脚本的，我们再此使用了两个官方提供的workflow。\n废话不多说，直接上代码\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 name: CI #自动化的名称 on: push: # push的时候触发 branches: # 那些分支需要触发 - master jobs: build: runs-on: ubuntu-latest # 镜像市场 steps: - name: checkout # 步骤的名称 uses: actions/checkout@master #软件市场的名称 with: # 参数 submodules: true - name: Setup Hugo uses: peaceiris/actions-hugo@v2.2.2 with: hugo-version: \u0026#39;0.59.1\u0026#39; extended: true - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v2.5.1 env: ACTIONS_DEPLOY_KEY: ${{ secrets.ACTIONS_DEPLOY_KEY }} EXTERNAL_REPOSITORY: homeant/homeant.github.io PUBLISH_BRANCH: master PUBLISH_DIR: ./public 准备部署 我们开发的项目及github pages实际是分开的，所以咱们出现了两个仓库，那怎么在开发项目buider完成后，部署到github pages呢，别慌，跟我一步一步来。\n生成提交代码用的ssh key 1 2 3 4 ssh-keygen -t rsa -b 4096 -C \u0026#34;$(git config user.email)\u0026#34; -f gh-pages -N \u0026#34;\u0026#34; # You will get 2 files: # gh-pages.pub (public key) # gh-pages (private key) 假设 开发项目为 tianhui.xin 部署的项目为 tianhui.github.io\n打开tianhui.xin仓库的settings，再点击Secrets，然后添加咱们刚刚生成的私钥，name为ACTIONS_DEPLOY_KEY\n同理，打开tianhui.github.io，点击Deploy keys，添加公钥，Allow write access一定要勾上，否则会无法提交\nAdd your public key Success Add your private key Success 然后，你就可以提交代码了，push成功后，打开仓库actions，至此部署成功，大功告成！\n相关文章:\n通过GitHub actions发布hugo到私有云服务器 ","date":"2019-11-17T03:00:00Z","permalink":"https://tianhui.xin/p/hugo%E9%80%9A%E8%BF%87github-action%E9%83%A8%E7%BD%B2%E5%88%B0github-pages/","title":"hugo通过Github Action部署到Github Pages"},{"content":"Nginx（发音同engine x）是异步框架的网页服务器，也可以用作反向代理、负载平衡器和HTTP缓存。2019年3月11日，Nginx公司被F5 Networks以6.7亿美元收购。\n在很多情况下，我们都需要在linux服务中安装nginx,今天我为大家带来，如何在linux系统中正确的安装nginx。\n安装gcc g++ centos 执行 1 2 yum -y install gcc automake autoconf libtool make yum install gcc gcc-c++ ububtu 执行 1 2 apt-get install build-essential apt-get install libtool 安装pcre 1 2 3 4 5 6 7 cd /usr/local/src/ wget https://ftp.pcre.org/pub/pcre/pcre-8.43.tar.gz tar -zxvf pcre-8.43.tar.gz cd pcre-8.43 ./configure make make install 安装zlib 1 2 3 4 5 6 wget http://www.zlib.net/zlib-1.2.11.tar.gz tar -zxvf zlib-1.2.11.tar.gz cd zlib-1.2.11 ./configure make make install 安装openssl 1 yum -y install openssl openssl-devel 安装nginx 1 2 3 4 5 6 wget http://nginx.org/download/nginx-1.14.2.tar.gz tar -zxvf nginx-1.14.2.tar.gz cd nginx-1.1.10 ./configure --prefix=/opt/software/nginx --with-http_stub_status_module --with-http_ssl_module make make install ","date":"2019-10-31T21:49:20Z","permalink":"https://tianhui.xin/p/linux-%E5%AE%89%E8%A3%85nginx/","title":"linux 安装nginx"},{"content":"在项目开发的实际过程中，经常会遇到需要生成id，或者订单号的业务，如果只是保证唯一，我们在分布式下，只需要考虑雪花算法就可以轻松实现，那么怎么去生成有规则有顺序的单号呢。\n表结构 注：数据库字段中出现tenant_id及version_可以无视，晨使用的jpa框架，其他框架可以自行扩展。\n1 2 3 4 5 6 7 8 9 10 11 CREATE TABLE `t_generator` ( `id` bigint(20) NOT NULL, `tenant_id` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `version_` bigint(20) NULL DEFAULT NULL, `seq_name` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `expression` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_bin NULL DEFAULT NULL, `value` bigint(20) NULL DEFAULT NULL, `increment` bigint(20) NULL DEFAULT NULL, `length` int(11) NOT NULL, PRIMARY KEY (`id`) USING BTREE ) ENGINE = InnoDB CHARACTER SET = utf8mb4 COLLATE = utf8mb4_bin ROW_FORMAT = Compact; 实体类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 @Data public class GeneratorEO{ private Long id; /** * 序列名称 */ private String seqName; /** * 执行表达式 */ private String expression; /** * 当前值 */ private Long value; /** * 自增值 */ private Long increment; /** * 序号的长度(位数) */ private int length; } 核心逻辑 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 @Transactional @Override public Object get(String seqName, String tenantId) { GeneratorEO generatorEO = baseRepository.findOne((root, criteriaQuery, criteriaBuilder) -\u0026gt; criteriaBuilder.equal(root.get(GeneratorEO.SEQ_NAME), seqName)).orElse(null); Object value = null; if (generatorEO != null) { ExpressionParser parser = new SpelExpressionParser(); EvaluationContext context = new StandardEvaluationContext(); Expression exp; Long oldValue = generatorEO.getValue(); String expression = generatorEO.getExpression(); context.setVariable(\u0026#34;tenantId\u0026#34;,generatorEO.getTenantId()); if(generatorEO.getLength()\u0026gt;0){ context.setVariable(\u0026#34;value\u0026#34;,String.format(\u0026#34;%0\u0026#34;+generatorEO.getLength()+\u0026#34;d\u0026#34;,oldValue)); }else{ context.setVariable(\u0026#34;value\u0026#34;,oldValue); } if (StringUtils.isNotBlank(expression)) { exp = parser.parseExpression(expression); } else { exp = parser.parseExpression(\u0026#34;#value\u0026#34;); } value = exp.getValue(context); exp = parser.parseExpression(\u0026#34;#value + #increment\u0026#34;); context.setVariable(\u0026#34;value\u0026#34;,oldValue); context.setVariable(\u0026#34;increment\u0026#34;,generatorEO.getIncrement()); Long newValue = (Long)exp.getValue(context); generatorEO.setValue(newValue); baseRepository.flush(); } return value; } 参考资料 Spring Expression Language\n","date":"2019-10-30T16:58:34Z","permalink":"https://tianhui.xin/p/%E5%9F%BA%E4%BA%8E%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E4%B8%BB%E9%94%AE_%E8%AE%A2%E5%8D%95%E5%8F%B7%E7%94%9F%E6%88%90%E7%AD%96%E7%95%A5/","title":"基于数据库的主键_订单号生成策略"},{"content":"Docker 是一个开源的应用容器引擎，基于 Go 语言 并遵从 Apache2.0 协议开源。\nDocker 可以让开发者打包他们的应用以及依赖包到一个轻量级、可移植的容器中，然后发布到任何流行的 Linux 机器上，也可以实现虚拟化。\n容器是完全使用沙箱机制，相互之间不会有任何接口（类似 iPhone 的 app）,更重要的是容器性能开销极低。\nDocker 从 17.03 版本之后分为 CE（Community Edition: 社区版） 和 EE（Enterprise Edition: 企业版），我们用社区版就可以了。\n1、docker -h 帮助\n2、获取镜像\nsudo docker pull NAME[:TAG]\nsudo docker pull centos:latest\n3、启动Container盒子\nsudo docker run [OPTIONS] IMAGE [COMMAND] [ARG\u0026hellip;]\nsudp docker run -t -i contos /bin/bash\n4、查看镜像列表，列出本地的所有images\nsudo docker images [OPTIONS] [NAME]\nsudo docker images centos\n5、查看容器列表，可看到我们创建过的所有container\nsudo docker ps [OPTIONS]\nsudo docker ps -a\n6、删除镜像，从本地删除一个已经下载的镜像\nsudo docker rmi IMAGE [IMAGE\u0026hellip;]\nsudo docker rmi centos:latest\n7、移除一个或多个容器实例\nsudo docker rm [OPTIONS] CONTAINER [CONTAINER\u0026hellip;]\n移除所有微运行的容器\nsudo docker rm sudo docker ps -aq\n8、停止一个正在运行的容器\nsudo docker kill [OPTIONS] CONTAINER [CONTAINNER\u0026hellip;]\nsudo docker kill 026e\n9、重启一个正在运行的容器\nsudo docker restart [OPTIONS] contains[CONTAINER]\nsudo docker restart 026e\n10、停止一个已经停止的容器\nsudo docker start [OPTIONS] CONTAINER [CONTAINER..]\nsudo docker start 026e\n11、进入某个正在运行的容器\ndocker exec [OPTIONS] [CONTAINER][COMMAND]\ndocker exec -it cloud-config /bin/bash\n","date":"2019-10-29T15:39:26Z","permalink":"https://tianhui.xin/p/docker%E5%91%BD%E4%BB%A4%E5%A4%A7%E5%85%A8/","title":"docker命令大全"},{"content":"idea作为目前java开发最常用的工具，针对其使用整理了一些快捷键，你绝对能用到\n常规 Ctrl+Shift + Enter，语句完成\n\u0026ldquo;!\u0026quot;，否定完成，输入表达式时按 \u0026ldquo;!\u0026ldquo;键\nCtrl+E，最近的文件\nCtrl+Shift+E，最近更改的文件\nShift+Click，可以关闭文件\nCtrl+[ OR ]，可以跑到大括号的开头与结尾\nCtrl+F12，可以显示当前文件的结构\nCtrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择\nCtrl+N，可以快速打开类\nCtrl+Shift+N，可以快速打开文件\nAlt+Q，可以看到当前方法的声明\nCtrl+P，可以显示参数信息\nCtrl+Shift+Insert，可以选择剪贴板内容并插入\nAlt+Insert，可以生成构造器/Getter/Setter等\nCtrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义\nCtrl+Alt+T，可以把代码包在一个块内，例如：try/catch\nCtrl+Enter，导入包，自动修正\nCtrl+Alt+L，格式化代码\nCtrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作\nCtrl+Alt+O，优化导入的类和包\nCtrl+R，替换文本\nCtrl+F，查找文本\nCtrl+Shift+Space，自动补全代码\nCtrl+空格，代码提示（与系统输入法快捷键冲突）\nCtrl+Shift+Alt+N，查找类中的方法或变量\nAlt+Shift+C，最近的更改\nAlt+Shift+Up/Down，上/下移一行\nShift+F6，重构 - 重命名\nCtrl+X，删除行\nCtrl+D，复制行\nCtrl+/或Ctrl+Shift+/，注释（//或者/**/）\nCtrl+J，自动代码（例如：serr）\nCtrl+Alt+J，用动态模板环绕\nCtrl+H，显示类结构图（类的继承层次）\nCtrl+Q，显示注释文档\nAlt+F1，查找代码所在位置\nAlt+1，快速打开或隐藏工程面板\nCtrl+Alt+left/right，返回至上次浏览的位置\nAlt+left/right，切换代码视图\nAlt+Up/Down，在方法间快速移动定位\nCtrl+Shift+Up/Down，向上/下移动语句\nF2 或 Shift+F2，高亮错误或警告快速定位\nTab，代码标签输入完成后，按 Tab，生成代码\nCtrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失\nAlt+F3，逐个往下查找相同文本，并高亮显示\nCtrl+Up/Down，光标中转到第一行或最后一行下\nCtrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）\nCtrl+Alt+B，跳转到方法实现处\nCtrl+Shift+Backspace，跳转到上次编辑的地方\nCtrl+O，重写方法\nCtrl+Alt+Space，类名自动完成\nCtrl+Alt+Up/Down，快速跳转搜索结果\nCtrl+Shift+J，整合两行\nAlt+F8，计算变量值\nCtrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本\nCtrl+Alt+Shift+V，简单粘贴\nShift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口\nF12，把焦点从编辑器移到最近使用的工具窗口\nShift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器\nCtrl+W，可以选择单词继而语句继而行继而函数\nCtrl+Shift+W，取消选择光标所在词\nAlt+F7，查找整个工程中使用地某一个类、方法或者变量的位置\nCtrl+I，实现方法\nCtrl+Shift+U，大小写转化\nCtrl+Y，删除当前行\nShift+Enter，向下插入新行\npsvm/sout，main/System.out.println(); Ctrl+J，查看更多\nCtrl+Shift+F，全局查找\nCtrl+F，查找/Shift+F3，向上查找/F3，向下查找\nCtrl+Shift+S，高级搜索\nCtrl+U，转到父类\nCtrl+Alt+S，打开设置对话框\nAlt+Shift+Inert，开启/关闭列选择模式\nCtrl+Alt+Shift+S，打开当前项目/模块属性\nCtrl+G，定位行\nAlt+Home，跳转到导航栏\nCtrl+Enter，上插一行\nCtrl+Backspace，按单词删除\nCtrl+\u0026quot;+/-\u0026quot;，当前方法展开、折叠\nCtrl+Shift+\u0026quot;+/-\u0026quot;，全部展开、折叠\n调试部分、编译 Ctrl+F2，停止\nAlt+Shift+F9，选择 Debug\nAlt+Shift+F10，选择 Run\nCtrl+Shift+F9，编译\nCtrl+Shift+F10，运行\nCtrl+Shift+F8，查看断点\nF8，步过\nF7，步入\nShift+F7，智能步入\nShift+F8，步出\nAlt+Shift+F8，强制步过\nAlt+Shift+F7，强制步入\nAlt+F9，运行至光标处\nCtrl+Alt+F9，强制运行至光标处\nF9，恢复程序\nAlt+F10，定位到断点\nCtrl+F8，切换行断点\nCtrl+F9，生成项目\nAlt+1，项目\nAlt+2，收藏\nAlt+6，TODO\nAlt+7，结构\nCtrl+Shift+C，复制路径\nCtrl+Alt+Shift+C，复制引用，必须选择类名\nCtrl+Alt+Y，同步\nCtrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）\nShift+F12，还原默认布局\nCtrl+Shift+F12，隐藏/恢复所有窗口\nCtrl+F4，关闭\nCtrl+Shift+F4，关闭活动选项卡\nCtrl+Tab，转到下一个拆分器\nCtrl+Shift+Tab，转到上一个拆分器\n重构 Ctrl+Alt+Shift+T，弹出重构菜单\nShift+F6，重命名\nF6，移动\nF5，复制\nAlt+Delete，安全删除\nCtrl+Alt+N，内联\n查找 Ctrl+F，查找\nCtrl+R，替换\nF3，查找下一个\nShift+F3，查找上一个\nCtrl+Shift+F，在路径中查找\nCtrl+Shift+R，在路径中替换\nCtrl+Shift+S，搜索结构\nCtrl+Shift+M，替换结构\nAlt+F7，查找用法\nCtrl+Alt+F7，显示用法\nCtrl+F7，在文件中查找用法\nCtrl+Shift+F7，在文件中高亮显示用法\nVCS Alt+~，VCS 操作菜单\nCtrl+K，提交更改\nCtrl+T，更新项目\nCtrl+Alt+Shift+D，显示变化【常规】\n","date":"2019-10-29T15:39:26Z","permalink":"https://tianhui.xin/p/idea-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/","title":"idea 常用快捷键"},{"content":"spring-integration是一个功能强大的EIP(Enterprise Integration Patterns)，即企业集成模式。对，spring-integration是一个集大成者。就我自己的理解，集成了众多功能的它，是一种便捷的事件驱动消息框架用来在系统之间做消息传递的。 今天我们来探索一下如果使用它发送http请求。\n什么是Spring Integration Spring Integration在基于Spring的应用程序中实现轻量级消息传递，并支持通过声明适配器与外部系统集成。 Spring Integration的主要目标是提供一个简单的模型来构建企业集成解决方案，同时保持关注点的分离，这对于生成可维护，可测试的代码至关重要。Spring Framework鼓励开发人员使用接口进行编码，并使用依赖注入（DI）为普通旧Java对象（POJO）提供执行其任务所需的依赖项。 Spring Integration将这一概念更进一步，其中POJO使用消息传递范例连接在一起，并且各个组件可能不了解应用程序中的其他组件。这种应用程序是通过组装细粒度可重用组件来构建的，以形成更高级别的功能。通过精心设计，这些流程可以模块化，并在更高的层次上重复使用。\n官方地址：spring-integration\n组成 Spring Integration 主要有Message、Channel、Message EndPoint组成。\nMessage Message是用来在不同部分之间传递的数据。Message有两部分组成:消息体(payload)与消息头(header)。消息体可以是任何数据类型；消息头表示的元数据就是解释消息体的内容。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 /** * A generic message representation with headers and body. * * @author Mark Fisher * @author Arjen Poutsma * @since 4.0 * @see org.springframework.messaging.support.MessageBuilder */ public interface Message\u0026lt;T\u0026gt; { /** * Return the message payload. */ T getPayload(); /** * Return message headers for the message (never {@code null} but may be empty). */ MessageHeaders getHeaders(); } Channel 在消息系统中，消息发送者发送消息到通道(Channel)，消息接受者从通道(Channel)接收消息。 MessageChannel 有两大子接口，分别是PollableChannel (可轮询)和SubscribableChannel(可订阅)。我们所有的消息通道类都是现实这两个接口。\nMessageChannel MessageChannel 是Spring Integration消息通道的顶级接口：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 public interface MessageChannel { /** * Constant for sending a message without a prescribed timeout. */ long INDEFINITE_TIMEOUT = -1; /** * Send a {@link Message} to this channel. If the message is sent successfully, * the method returns {@code true}. If the message cannot be sent due to a * non-fatal reason, the method returns {@code false}. The method may also * throw a RuntimeException in case of non-recoverable errors. * \u0026lt;p\u0026gt;This method may block indefinitely, depending on the implementation. * To provide a maximum wait time, use {@link #send(Message, long)}. * @param message the message to send * @return whether or not the message was sent */ boolean send(Message\u0026lt;?\u0026gt; message); /** * Send a message, blocking until either the message is accepted or the * specified timeout period elapses. * @param message the message to send * @param timeout the timeout in milliseconds or {@link #INDEFINITE_TIMEOUT} * @return {@code true} if the message is sent, {@code false} if not * including a timeout of an interrupt of the send */ boolean send(Message\u0026lt;?\u0026gt; message, long timeout); } PollableChannel PollableChannel 具备轮询获得消息的能力。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public interface PollableChannel extends MessageChannel { /** * Receive a message from this channel, blocking indefinitely if necessary. * @return the next available {@link Message} or {@code null} if interrupted */ Message\u0026lt;?\u0026gt; receive(); /** * Receive a message from this channel, blocking until either a message is available * or the specified timeout period elapses. * @param timeout the timeout in milliseconds or {@link MessageChannel#INDEFINITE_TIMEOUT}. * @return the next available {@link Message} or {@code null} if the specified timeout * period elapses or the message reception is interrupted */ Message\u0026lt;?\u0026gt; receive(long timeout); } SubscribableChannel SubscribableChannel 发送消息给订阅了MessageHanlder的订阅者\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public interface SubscribableChannel extends MessageChannel { /** * Register a message handler. * @return {@code true} if the handler was subscribed or {@code false} if it * was already subscribed. */ boolean subscribe(MessageHandler handler); /** * Un-register a message handler. * @return {@code true} if the handler was un-registered, or {@code false} * if was not registered. */ boolean unsubscribe(MessageHandler handler); } 消息通道 PublishSubscribeChannel PublishSubscribeChannel允许广播消息给所有订阅者，配置方式如下：\n1 2 3 4 5 6 7 8 9 /** * 允许广播消息给所有订阅者，当前消息通道的id为publishSubscribeChannel * @return */ @Bean public PublishSubscribeChannel publishSubscribeChannel(){ PublishSubscribeChannel channel = new PublishSubscribeChannel(); return channel; } QueueChannel QueueChannel允许消息接收者轮询获得消息，用一个队列(queue)接收消息，队列的容量大小可配置，配置方式如下：\n1 2 3 4 5 @Bean public QueueChannel queueChannel(){ QueueChannel channel = new QueueChannel(10);//10的队列的容量 return channel; } PriorityChannel PriorityChannel可按照优先级将数据存储到队列，它依据于消息的消息头priority属性，配置方式如下：\n1 2 3 4 5 @Bean public PriorityChannel priorityChannel(){ PriorityChannel channel = new PriorityChannel(10); return channel; } RendezvousChannel RendezvousChannel确保每一个接收者都接收到消息后再发送消息，配置方式如下：\n1 2 3 4 5 @Bean public RendezvousChannel rendezvousChannel(){ RendezvousChannel channel = new RendezvousChannel(); return channel; } DirectChannel DirectChannel是Spring Integration默认的消息通道，它允许将消息发送给为一个订阅者，然后阻碍发送直到消息被接收，配置方式如下：\n1 2 3 4 5 @Bean public DirectChannel directChannel(){ DirectChannel channel = new DirectChannel(); return channel; } ExecutorChannel ExecutorChannel可绑定一个多线程的task executor，配置方式如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @Bean public ExecutorChannel executorChannel(){ ExecutorChannel channel = new ExecutorChannel(executor()); return channel; } @Bean public Executor executor(){ ThreadPoolTaskExecutor taskExecutor = new ThreadPoolTaskExecutor(); taskExecutor.setCorePoolSize(5); taskExecutor.setMaxPoolSize(10); taskExecutor.setQueueCapacity(25); taskExecutor.initialize(); return taskExecutor; } 通道拦截器 ChannelInterceptor Spring Integration给消息通道提供了通道拦截器(ChannelInterceptor)，用来拦截发送和接收消息的操作。 ChannelInterceptor接口定义如下，我们只需要实现这个接口即可：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public interface ChannelInterceptor { Message\u0026lt;?\u0026gt; preSend(Message\u0026lt;?\u0026gt; message, MessageChannel channel); void postSend(Message\u0026lt;?\u0026gt; message, MessageChannel channel, boolean sent); void afterSendCompletion(Message\u0026lt;?\u0026gt; message, MessageChannel channel, boolean sent, Exception ex); boolean preReceive(MessageChannel channel); Message\u0026lt;?\u0026gt; postReceive(Message\u0026lt;?\u0026gt; message, MessageChannel channel); void afterReceiveCompletion(Message\u0026lt;?\u0026gt; message, MessageChannel channel, Exception ex); } Message EndPoint 消息端点(Message EndPoint)是真正处理消息的(Message)组件，它还可以控制通道的路由。\nChannel Adapter 通道适配器(Channel Adapter)是一种连接外部系统或传输协议的端点(EndPoint)，可以分为入站(inbound)和出站(outbound)。 通道适配器是单向的，入站通道适配器只支持接收消息，出站通道适配器只支持输出消息。 Spring Integration内置了如下的适配器：\n1 RabbitMQ、Feed、File、FTP/SFTP、Gemfire、HTTP、TCP/UDP、JDBC、JPA、JMS、Mail、MongoDB、Redis、RMITwitter、XMPP、WebServices(SOAP、REST)、WebSocket Gateway 消息网关(Gateway)类似于Adapter，但是提供了双向的请求/返回集成方式，也分为入站(inbound)和出站(outbound)。 Spring Integration 对响应的Adapter都提供了Gateway。\nService Activator Service Activator 可调用Spring的Bean来处理消息，并将处理后的结果输出到指定的消息通道。\nRouter 路由(Router) 可根据消息体内容(Payload Type Router)、消息头的值(Header Value Router) 以及定义好的接收表(Recipient List Router) 作为条件，来决定消息传递到的通道。\nFilter 过滤器(Filter) 类似于路由(Router)，不同的是过滤器不决定消息路由到哪里，而是决定消息是否可以传递给消息通道。\nSplitter 拆分器(Splitter)将消息拆分为几个部分单独处理，拆分器处理的返回值是一个集合或者数组。\nAggregator 聚合器(Aggregator)与拆分器相反，它接收一个java.util.List作为参数，将多个消息合并为一个消息。\nEnricher 当我们从外部获得消息后，需要增加额外的消息到已有的消息中，这时就需要使用消息增强器(Enricher)。消息增强器主要有消息体 增强器(Payload Enricher)和消息头增强器(Header Enricher)两种。\nTransformer 转换器(Transformer)是对获得的消息进行一定的转换处理(如数据格式转换)。\nBridge 使用连接桥(Bridge)可以简单的将两个消息通道连接起来。\n快速入门 阅读官方文档它是这样描述的：\nIn the following \u0026ldquo;quick start\u0026rdquo; application you can see that the same gateway interface is used to invoke two completely different service implementations. To build and run this program you will need the spring-integration-ws and spring-integration-xml modules as described above.\n大概意思是使用这个示例，需要spring-integration-ws和spring-integration-xml两个模块，同时它使用了相同的网关接口调用了两个不同的服务实现。\n编写快速启动类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public class Main { public static void main(String... args) throws Exception { ApplicationContext ctx = new ClassPathXmlApplicationContext(\u0026#34;context.xml\u0026#34;); // Simple Service TempConverter converter = ctx.getBean(\u0026#34;simpleGateway\u0026#34;, TempConverter.class); System.out.println(converter.fahrenheitToCelcius(68.0f)); // Web Service converter = ctx.getBean(\u0026#34;wsGateway\u0026#34;, TempConverter.class); System.out.println(converter.fahrenheitToCelcius(68.0f)); } } 编写接口类 1 2 3 4 5 public interface TempConverter { float fahrenheitToCelcius(float fahren); } 编写xml 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 \u0026lt;!-- Simple Service --\u0026gt; \u0026lt;!-- 网关:simpleGateway --\u0026gt; \u0026lt;int:gateway id=\u0026#34;simpleGateway\u0026#34; service-interface=\u0026#34;foo.TempConverter\u0026#34; default-request-channel=\u0026#34;simpleExpression\u0026#34; /\u0026gt; \u0026lt;int:service-activator id=\u0026#34;expressionConverter\u0026#34; input-channel=\u0026#34;simpleExpression\u0026#34; expression=\u0026#34;(payload - 32) / 9 * 5\u0026#34;/\u0026gt; \u0026lt;!-- Web Service --\u0026gt; \u0026lt;int:gateway id=\u0026#34;wsGateway\u0026#34; service-interface=\u0026#34;foo.TempConverter\u0026#34; default-request-channel=\u0026#34;viaWebService\u0026#34; /\u0026gt; \u0026lt;int:chain id=\u0026#34;wsChain\u0026#34; input-channel=\u0026#34;viaWebService\u0026#34;\u0026gt; \u0026lt;int:transformer expression=\u0026#34;\u0026#39;\u0026amp;lt;FahrenheitToCelsius xmlns=\u0026amp;quot;https://www.w3schools.com/xml/\u0026amp;quot;\u0026amp;gt;\u0026amp;lt;Fahrenheit\u0026amp;gt;XXX\u0026amp;lt;/Fahrenheit\u0026amp;gt;\u0026amp;lt;/FahrenheitToCelsius\u0026amp;gt;\u0026#39;.replace(\u0026#39;XXX\u0026#39;, payload.toString())\u0026#34; /\u0026gt; \u0026lt;int-ws:header-enricher\u0026gt; \u0026lt;int-ws:soap-action value=\u0026#34;https://www.w3schools.com/xml/FahrenheitToCelsius\u0026#34;/\u0026gt; \u0026lt;/int-ws:header-enricher\u0026gt; \u0026lt;int-ws:outbound-gateway uri=\u0026#34;https://www.w3schools.com/xml/tempconvert.asmx\u0026#34;/\u0026gt; \u0026lt;int-xml:xpath-transformer xpath-expression=\u0026#34;/*[local-name()=\u0026#39;FahrenheitToCelsiusResponse\u0026#39;]/*[local-name()=\u0026#39;FahrenheitToCelsiusResult\u0026#39;]\u0026#34;/\u0026gt;\u0026lt;/int:chain\u0026gt; 咦，嫌弃，和我们想用的内容有差距啊，,既然用SpringBoot那就得跟上节奏，JavaBean配置，接着往下看\nAnd here is the same application (web service part) using the Java DSL (and Spring Boot). You will need the spring-boot-starter-integration dependency or spring-integration-java-dsl directly if you don’t use Spring Boot. If you use Spring Integration starting version 5.0, you don’t need any additional dependencies - the Java DSL is included to the core project\n进入正题了，大意是使用JavaBean配置或者spring boot的示例，如果不实用Spring Boot那么就需要咱们手动加入spring-boot-starter-integration或者spring-integration-java-dsl所依赖的模块，如果使用的是5.0及以上的版本，那么你不需要手动引入依赖，Java DSL已经包含在其中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @Configuration @SpringBootApplication @IntegrationComponentScan public class Application { public static void main(String[] args) { ConfigurableApplicationContext ctx = SpringApplication.run(Application.class, args); TempConverter converter = ctx.getBean(TempConverter.class); System.out.println(converter.fahrenheitToCelcius(68.0f)); ctx.close(); } @MessagingGateway public interface TempConverter { @Gateway(requestChannel = \u0026#34;convert.input\u0026#34;) float fahrenheitToCelcius(float fahren); } @Bean public IntegrationFlow convert() { return f -\u0026gt; f .transform(payload -\u0026gt; \u0026#34;\u0026lt;FahrenheitToCelsius xmlns=\\\u0026#34;https://www.w3schools.com/xml/\\\u0026#34;\u0026gt;\u0026#34; + \u0026#34;\u0026lt;Fahrenheit\u0026gt;\u0026#34; + payload + \u0026#34;\u0026lt;/Fahrenheit\u0026gt;\u0026#34; + \u0026#34;\u0026lt;/FahrenheitToCelsius\u0026gt;\u0026#34;) .enrichHeaders(h -\u0026gt; h .header(WebServiceHeaders.SOAP_ACTION, \u0026#34;https://www.w3schools.com/xml/FahrenheitToCelsius\u0026#34;)) .handle(new SimpleWebServiceOutboundGateway( \u0026#34;https://www.w3schools.com/xml/tempconvert.asmx\u0026#34;)) .transform(Transformers.xpath(\u0026#34;/*[local-name()=\\\u0026#34;FahrenheitToCelsiusResponse\\\u0026#34;]\u0026#34; + \u0026#34;/*[local-name()=\\\u0026#34;FahrenheitToCelsiusResult\\\u0026#34;]\u0026#34;)); } } 开始使用 翻阅了一遍官网的samples，根本没找到http方式关于SpringBoot的示例，没事，咱们活学活用，参考其他模块，直接上代码\npom中加入依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-integration\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.integration\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-integration-http\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;jackson-module-kotlin\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;com.fasterxml.jackson.module\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写测试类 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 @Slf4j @RunWith(SpringRunner.class) @SpringBootTest public class ApplicationTest { @Autowired private Config.TempConverter tempConverter; @Test public void test() { //字符串方式 final String info = tempConverter.hello(\u0026#34;homeant\u0026#34;); log.debug(\u0026#34;info:{}\u0026#34;, info); //实体对象方式 log.debug(\u0026#34;userInfo:{}\u0026#34;, tempConverter.userInfo(\u0026#34;homeant\u0026#34;)); } @Configuration @EnableIntegration @IntegrationComponentScan @EnableAutoConfiguration public static class Config { @MessagingGateway public interface TempConverter { @Gateway(requestChannel = \u0026#34;convert.input\u0026#34;) String hello(String name); @Gateway(requestChannel = \u0026#34;userInfo.input\u0026#34;) UserInfo userInfo(String name); } @Bean public IntegrationFlow convert() { return f -\u0026gt; f.handle(Http.outboundGateway(\u0026#34;https://api.github.com/users/{name}\u0026#34;) .httpMethod(HttpMethod.GET) .expectedResponseType(String.class).uriVariable(\u0026#34;name\u0026#34;, r -\u0026gt; r.getPayload())) .log(LoggingHandler.Level.DEBUG).bridge(); } @Bean public IntegrationFlow userInfo() { return f -\u0026gt; f.handle(Http.outboundGateway(\u0026#34;https://api.github.com/users/{name}\u0026#34;) .uriVariable(\u0026#34;name\u0026#34;, r -\u0026gt; r.getPayload()) .httpMethod(HttpMethod.GET) .expectedResponseType(UserInfo.class)) .log(LoggingHandler.Level.DEBUG).bridge(); } } } 启动测试类 1 2 [2019-09-30 22:11:54.977] [main] [DEBUG] [fun.vyse.cloud.test.ApplicationTest :34 ] - info:{\u0026#34;login\u0026#34;:\u0026#34;homeant\u0026#34;,\u0026#34;id\u0026#34;:28803295,\u0026#34;node_id\u0026#34;:\u0026#34;MDQ6VXNlcjI4ODAzMjk1\u0026#34;,\u0026#34;avatar_url\u0026#34;:\u0026#34;https://avatars0.githubusercontent.com/u/28803295?v=4\u0026#34;,\u0026#34;gravatar_id\u0026#34;:\u0026#34;\u0026#34;,\u0026#34;url\u0026#34;:\u0026#34;https://api.github.com/users/homeant\u0026#34;,\u0026#34;html_url\u0026#34;:\u0026#34;https://github.com/homeant\u0026#34;,\u0026#34;followers_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/followers\u0026#34;,\u0026#34;following_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/following{/other_user}\u0026#34;,\u0026#34;gists_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/gists{/gist_id}\u0026#34;,\u0026#34;starred_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/starred{/owner}{/repo}\u0026#34;,\u0026#34;subscriptions_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/subscriptions\u0026#34;,\u0026#34;organizations_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/orgs\u0026#34;,\u0026#34;repos_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/repos\u0026#34;,\u0026#34;events_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/events{/privacy}\u0026#34;,\u0026#34;received_events_url\u0026#34;:\u0026#34;https://api.github.com/users/homeant/received_events\u0026#34;,\u0026#34;type\u0026#34;:\u0026#34;User\u0026#34;,\u0026#34;site_admin\u0026#34;:false,\u0026#34;name\u0026#34;:\u0026#34;俊晨\u0026#34;,\u0026#34;company\u0026#34;:null,\u0026#34;blog\u0026#34;:\u0026#34;https://tianhui.xin\u0026#34;,\u0026#34;location\u0026#34;:\u0026#34;China-BeiJing\u0026#34;,\u0026#34;email\u0026#34;:null,\u0026#34;hireable\u0026#34;:null,\u0026#34;bio\u0026#34;:\u0026#34;高山仰止，景行行止。虽不能至，心向往之\u0026#34;,\u0026#34;public_repos\u0026#34;:15,\u0026#34;public_gists\u0026#34;:0,\u0026#34;followers\u0026#34;:3,\u0026#34;following\u0026#34;:3,\u0026#34;created_at\u0026#34;:\u0026#34;2017-05-19T08:53:17Z\u0026#34;,\u0026#34;updated_at\u0026#34;:\u0026#34;2019-09-27T06:10:27Z\u0026#34;} [2019-09-30 22:11:55.971] [main] [DEBUG] [fun.vyse.cloud.test.ApplicationTest :35 ] - userInfo:UserInfo(login=homeant, id=28803295, node_id=MDQ6VXNlcjI4ODAzMjk1, avatar_url=https://avatars0.githubusercontent.com/u/28803295?v=4, gravatar_id=, url=https://api.github.com/users/homeant, html_url=https://github.com/homeant, followers_url=https://api.github.com/users/homeant/followers, following_url=https://api.github.com/users/homeant/following{/other_user}, gists_url=https://api.github.com/users/homeant/gists{/gist_id}, starred_url=https://api.github.com/users/homeant/starred{/owner}{/repo}, subscriptions_url=https://api.github.com/users/homeant/subscriptions, organizations_url=https://api.github.com/users/homeant/orgs, repos_url=https://api.github.com/users/homeant/repos, events_url=https://api.github.com/users/homeant/events{/privacy}, received_events_url=https://api.github.com/users/homeant/received_events, type=User, site_admin=false, name=俊晨, company=null, blog=https://tianhui.xin, location=China-BeiJing, email=null, hireable=null, bio=高山仰止，景行行止。虽不能至，心向往之, public_repos=15, public_gists=0, followers=3, following=3, created_at=2017-05-19T08:53:17Z, updated_at=2019-09-27T06:10:27Z) 参考文档\nspring-integration-samples\nspring-integration初探\nspring doc\n","date":"2019-09-30T22:59:24Z","permalink":"https://tianhui.xin/p/springboot%E4%B8%AD%E4%BD%BF%E7%94%A8springintegration/","title":"SpringBoot中使用SpringIntegration"},{"content":"在学习Spring Boot的过程中，接触最多的就是starter。使用者可以把starter当成是一种服务，使得使用某个功能时不需要关注各种依赖库的处理，不需要具体的配置信息，由Spring Boot自动通过classpath路径下的类发现需要的Bean，并织入bean。而自动装配就是Springboot最大的特性。\n什么是定制starter springBoot官方推出了很多的starter，那么在这些starter的背后，它的启动流程是什么？starter包含两大模块：\nautoconfigure 自动配置类 starter 包含autoconfigure配置和其他的依赖 加入springBoot依赖 1 2 3 4 5 6 7 8 9 10 11 \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-configuration-processor\u0026lt;/artifactId\u0026gt; \u0026lt;optional\u0026gt;true\u0026lt;/optional\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-autoconfigure\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 编写bean对象 1 2 3 4 5 public class Hello { public void say(String msg){ System.out.println(msg); } } 编写starter 1 2 3 4 5 6 7 @Configuration public class DemoAutoConfiguration { @Bean public Hello hello() { return new Hello(); } } 编写spring.factories 在 src/main/resources 目录下新建 META-INF 文件夹，然后新建 spring.factories 文件，这个文件用于告诉Spring Boot有那些自动配置类需要处理，因此它的内容是\n1 2 org.springframework.boot.autoconfigure.EnableAutoConfiguration=\\ xin.tianhui.cloud.starter.DemoAutoConfiguration 使用 在使用的项目中加入maven依赖,也就是咱们刚刚写好的starter\n1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;xin.tianhui.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;demo-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;0.0.1-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 代码中注入starter初始化好的bean 1 2 3 4 5 6 7 8 public class Application{ @Autowired private Hello hello; public void test(){ hello.say(\u0026#34;hello\u0026#34;); } } ","date":"2019-09-08T13:05:34Z","permalink":"https://tianhui.xin/p/springboot-%E5%AE%9A%E5%88%B6%E8%87%AA%E5%B7%B1%E7%9A%84starter/","title":"springBoot 定制自己的starter"},{"content":"BeanFactory，它是一个接口工厂类，用于管理spring中的Bean。在Spring中，BeanFactory是IOC容器的核心接口，它的职责包括：实例化、定位、配置应用程序中的对象及建立这些对象间的依赖。 Spring为我们提供了许多易用的BeanFactory实现，XmlBeanFactory就是常用的一个，该实现将以XML方式描述组成应用的对象及对象间的依赖关系。XmlBeanFactory类将持有此XML配置元数据，并用它来构建一个完全可配置的系统或应用。\nBeanFactory接口 是Spring bean容器的根接口.提供获取bean,是否包含bean,是否单例与原型,获取bean类型,bean 别名的方法 BeanFactory的三个子接口 HierarchicalBeanFactory：提供父容器的访问功能 ListableBeanFactory：提供了批量获取Bean的方法 AutowireCapableBeanFactory：在BeanFactory基础上实现对已存在实例的管理 ConfigurableBeanFactory ConfigurableListableBeanFactory 继承了上述的所有接口，增加了其他功能：比如类加载器,类型转化,属性编辑器,BeanPostProcessor,作用域,bean定义,处理bean依赖关系, bean如何销毁… 实现类DefaultListableBeanFactory 实现了ConfigurableListableBeanFactory，实现上述BeanFactory所有功能。它还可以注册BeanDefinition ClassPathXmlApplicationContext是BeanFactory的一个典型的实现，同时它也是 ApplicationContext的子类，ClassPathXmlApplicationContext从 xml 的配置文件中获取 bean 并且管理他们。\n1 2 3 4 5 public static void main(String[] args) throws Exception { BeanFactory bf = new ClassPathXmlApplicationContext(\u0026#34;application.xml\u0026#34;); UserHandler userHandler = (UserHandler) bf.getBean(\u0026#34;userHandler\u0026#34;); log.info(\u0026#34;handler:{}\u0026#34;,userHandler); } xml配置 1 2 3 \u0026lt;bean id=\u0026#34;userHandler\u0026#34; class=\u0026#34;fun.vyse.cloud.UserHandler\u0026#34;\u0026gt; \u0026lt;property name=\u0026#34;userService\u0026#34; ref=\u0026#34;userService\u0026#34;/\u0026gt; \u0026lt;/bean\u0026gt; 文章参考：【Spring4揭秘 BeanFactory】基本容器-BeanFactory\n未完待续\u0026hellip;\n","date":"2019-04-22T14:03:17Z","image":"https://image.tianhui.xin/spring/beanFactory/01.png?x-oss-process=style/make","permalink":"https://tianhui.xin/p/beanfactory%E8%AF%A6%E8%A7%A3/","title":"BeanFactory详解"},{"content":"activiti表结构\n表结构 表分类 表名 解释 一般数据 ACT_GE_BYTEARRAY 通用的流程定义和流程资源 ACT_GE_PROPERTY 系统相关属性 流程历史记录 ACT_HI_ACTINST 历史的流程实例 ACT_HI_ATTACHMENT 历史的流程附件 ACT_HI_COMMENT 历史的说明性信息 ACT_HI_DETAIL 历史的流程运行中的细节信息 ACT_HI_IDENTITYLINK 历史的流程运行过程中用户关系 ACT_HI_PROCINST 历史的流程实例 ACT_HI_TASKINST 历史的任务实例 ACT_HI_VARINST 历史的流程运行中的变量信息 用户用户组表 ACT_ID_GROUP 身份信息-组信息 ACT_ID_INFO 身份信息-组信息 ACT_ID_MEMBERSHIP 身份信息-用户和组关系的中间表 ACT_ID_USER 身份信息-用户信息 流程定义表 ACT_RE_DEPLOYMENT 部署单元信息 ACT_RE_MODEL 模型信息 ACT_RE_PROCDEF 已部署的流程定义 运行实例表 ACT_RU_EVENT_SUBSCR 运行时事件 ACT_RU_EXECUTION 运行时流程执行实例 ACT_RU_IDENTITYLINK 运行时用户关系信息 ACT_RU_JOB 运行时作业 ACT_RU_TASK 运行时任务 ACT_RU_VARIABLE 运行时变量表 流程查询 1 2 3 4 5 6 7 8 9 10 /*得到流程*/ SELECT ACT_RE_PROCDEF.ID_, ACT_RE_PROCDEF.NAME_, ACT_RE_PROCDEF.DESCRIPTION_ FROM ACT_RE_PROCDEF LEFT JOIN ACT_RE_DEPLOYMENT ON ACT_RE_PROCDEF.DEPLOYMENT_ID_ = ACT_RE_DEPLOYMENT.ID_ WHERE ACT_RE_PROCDEF.KEY_ = ?; 查询流程正在运行的任务 1 2 3 4 5 6 7 8 9 10 11 SELECT art.ID_, art.art.EXECUTION_ID_, art.PROC_INST_ID_, art.NAME_, art.ASSIGNEE_, art.CREATE_TIME_ FROM ACT_RU_TASK art WHERE art.PROC_DEF_ID_= ?; 查询正常运行的流程实例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SELECT art.ID_ TASK_ID_, art.EXECUTION_ID_, art.PROC_INST_ID_, art.NAME_, art.ASSIGNEE_, art.CREATE_TIME_, are.PARENT_ID_, are.PROC_DEF_ID_, are.ROOT_PROC_INST_ID_, are.ACT_ID_, are.START_TIME_ FROM ACT_RU_TASK art LEFT JOIN ACT_RU_EXECUTION are ON art.EXECUTION_ID_ = are.ID_ WHERE art.PROC_DEF_ID_ = ?; 查询流程实例变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 SELECT arv.ID_, arv.TYPE_, arv.NAME_, CASE arv.TYPE_ WHEN \u0026#39;string\u0026#39; THEN arv.TEXT_ WHEN \u0026#39;boolean\u0026#39; THEN arv.LONG_ WHEN \u0026#39;integer\u0026#39; THEN arv.LONG_ ELSE \u0026#39;\u0026#39; END VALUE_ FROM ACT_RU_VARIABLE arv WHERE arv.EXECUTION_ID_ = ?; 1 2 3 4 5 6 7 select distinct RES.* from ACT_RE_PROCDEF RES WHERE RES.KEY_ = \u0026#39;leave\u0026#39; and (RES.SUSPENSION_STATE_ = 1) order by RES.ID_ asc; select distinct RES.* from ACT_RU_TASK RES WHERE RES.PROC_DEF_ID_ = \u0026#39;leave:1:866908b5-1fb6-11e9-a502-4c348832211f\u0026#39; order by RES.ID_ asc; /*查询历史流程*/ select distinct RES.* , DEF.KEY_ as PROC_DEF_KEY_, DEF.NAME_ as PROC_DEF_NAME_, DEF.VERSION_ as PROC_DEF_VERSION_, DEF.DEPLOYMENT_ID_ as DEPLOYMENT_ID_ from ACT_HI_PROCINST RES left outer join ACT_RE_PROCDEF DEF on RES.PROC_DEF_ID_ = DEF.ID_ order by RES.END_TIME_ desc; /*查询正在运行的流程*/ select distinct RES.* from ACT_RU_TASK RES WHERE RES.ASSIGNEE_ = \u0026#39;leader\u0026#39; and RES.TASK_DEF_KEY_ = \u0026#39;dept_leave_audit\u0026#39; and RES.SUSPENSION_STATE_ = 1 order by RES.ID_ asc; cloud project desc activiti-cloud-runtime-bundle-service 运行时 activiti-cloud-audit-service 审计 activiti-cloud-query-service 查询 ","date":"2019-04-21T14:03:17Z","permalink":"https://tianhui.xin/p/activiti%E8%A1%A8%E7%BB%93%E6%9E%84/","title":"activiti表结构"},{"content":" 随着微服务的流行，服务和服务之间的稳定性变得越来越重要。 Sentinel 以流量为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。\nSentinel特征 丰富的应用场景： Sentinel 承接了阿里巴巴近 10 年的双十一大促流量的核心场景，例如秒杀（即突发流量控制在系统容量可以承受的范围）、消息削峰填谷、实时熔断下游不可用应用等。\n完备的实时监控： Sentinel 同时提供实时的监控功能。您可以在控制台中看到接入应用的单台机器秒级数据，甚至 500 台以下规模的集群的汇总运行情况。\n广泛的开源生态： Sentinel 提供开箱即用的与其它开源框架/库的整合模块，例如与 Spring Cloud、Dubbo、gRPC 的整合。您只需要引入相应的依赖并进行简单的配置即可快速地接入 Sentinel。\n完善的 SPI 扩展点： Sentinel 提供简单易用、完善的 SPI 扩展点。您可以通过实现扩展点，快速的定制逻辑。例如定制规则管理、适配数据源等。\nSentinel控制台 Sentinel提供了两种使用方式,包括使用阿里云提供的服务,当初推广的时候是免费的\n在线控制台\n下载地址\n项目使用Sentinel(阿里云控制台) ahas文档\n引入ahas依赖 1 2 3 4 5 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.csp\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;ahas-sentinel-client\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.6.4\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; 添加bean 1 2 3 4 5 6 7 8 9 @Bean public FilterRegistrationBean sentinelFilterRegistration() { FilterRegistrationBean registration = new FilterRegistrationBean(); registration.setFilter(new CommonFilter()); registration.addUrlPatterns(\u0026#34;/*\u0026#34;); registration.setName(\u0026#34;sentinelCommonFilter\u0026#34;); registration.setOrder(1); return registration; } 项目启动 1 java Dproject.name=AppName -Dahas.license=\u0026lt;License\u0026gt; -jar xxxx.jar 使用自己搭建的控制台 启动Sentinel控制台 1 java -Dserver.port=8081 -Dcsp.sentinel.dashboard.server=localhost:8081 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.7.2.jar PS:用户名密码都是sentinel\n引入依赖 1 2 3 4 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba.cloud\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-cloud-starter-alibaba-sentinel\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 简单示例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @SpringBootApplication public class SentinelApplication { public static void main(String[] args) { SpringApplication.run(SentinelApplication.class, args); } } @RestController public class IndexController { @Autowired private SayHelloService sayHelloService; @GetMapping public String sayHello(String name) { return sayHelloService.sayHello(name); } } public interface SayHelloService { String sayHello(String name); } @Slf4j @Service public class SayHelloServiceImpl implements SayHelloService { @SentinelResource(\u0026#34;sayHello\u0026#34;) public String sayHello(String name) { log.info(Thread.currentThread().getName()); try { Thread.sleep(1000); }catch (Exception e){ e.printStackTrace(); } return \u0026#34;hello \u0026#34;.concat(name).concat(\u0026#34;!\u0026#34;); } } application.yaml配置 1 2 3 4 5 6 7 spring: application: name: spring-cloud-sentinel sentinel: transport: port: 8081 dashboard: localhost:8081 @SentinelResource注解用来标识资源是否被限流、降级。上述例子上该注解的属性 sayHello 表示资源名。\n规则配置 流控规则》新增流控规则\n输入资源名,和代码中@SentinelResource注解的值对应 根据对应需求选择阈值类型,分为QPS及线程数 设置阈值类型对应的数值,比如同一时间内只允许有一个线程访问,可以选择为线程数,单机阈值为1 线程测试 测试环境：阈值类型为线程数,单机阈值为10,jMeter设置线程为20,失败率为50%\nQPS测试 测试环境：阈值类型为QPS,单机阈值为10,jMeter设置线程为20,失败率为40%\n代码地址\n","date":"2019-04-21T14:03:17Z","permalink":"https://tianhui.xin/p/springboot%E4%B8%AD%E4%BD%BF%E7%94%A8sentinel/","title":"springboot中使用sentinel"},{"content":"webpack4 开发环境搭建\nnpm 初始化项目 1 yarn init 安装webpack依赖 1 yarn add webpack webpack-dev-server webpack-cli @webpack-cli/init --dev webpack 初始化 1 npx webpack-cli init 1 2 3 4 5 6 7 ? Will your application have multiple bundles? Yes ? Type the names you want for your modules (entry files), separated by comma [example: app,vendor] app ? What is the location of \u0026#34;app\u0026#34;? [example: ./src/app] ./src/app ? Which folder will your generated bundles be in? [default: dist]: dist ? Will you be using ES2015? Yes ? Will you use one of the below CSS solutions? SASS yarn add v1.12.1 添加编译插件 1 2 3 4 5 6 ## 二选一 ## 1. class 写法 向下兼容 yarn add @babel/plugin-proposal-class-properties --dev ## 2. babel 支持 import ## yarn add @babel/plugin-syntax-dynamic-import --dev yarn add @babel/preset-env @babel/core cross-env --dev 安装loader 1 yarn add html-withimg-loader url-loader file-loader style-loader postcss-loader --dev 插件安装 1 yarn add mini-css-extract-plugin uglifyjs-webpack-plugin clean-webpack-plugin copy-webpack-plugin extract-css html-webpack-plugin --dev 安装webpack-chain 1 yarn add webpack-chain --dev 此处webpack-chain为5.0.1版本，是针对webpack 4维护的，需特别注意\ngithub地址：webpack-chain\n创建webpack.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 const path = require(\u0026#39;path\u0026#39;); const isProd = process.env.NODE_ENV === \u0026#39;production\u0026#39;; const MiniCssExtractPlugin = require(\u0026#34;mini-css-extract-plugin\u0026#34;); const WebpackChain = require(\u0026#39;webpack-chain\u0026#39;); const config = new WebpackChain(); config.when(isProd,config=\u0026gt;{ config.entry(\u0026#39;index\u0026#39;).add(\u0026#39;./src/index.js\u0026#39;); }).when(!isProd,config=\u0026gt;{ config.entry(\u0026#39;index\u0026#39;).add(\u0026#39;./src/index.js\u0026#39;); }) // Modify output settings .output .path(path.join(__dirname, \u0026#34;dist\u0026#34;)).filename(\u0026#39;[name].js\u0026#39;).end() .when(isProd, config =\u0026gt; { config.mode(\u0026#39;production\u0026#39;); }).when(!isProd,config=\u0026gt;{ config.mode(\u0026#39;development\u0026#39;).devtool(\u0026#39;source-map\u0026#39;); }).end(); /** * module */ config .module .rule(\u0026#34;compile\u0026#34;) .test(/\\.js$/) .include.add(path.join(__dirname,\u0026#39;src\u0026#39;)).end() .exclude.add(/node_modules/).end() .use(\u0026#39;babel\u0026#39;).loader(\u0026#34;babel-loader\u0026#34;) .options({ presets: [\u0026#39;@babel/preset-env\u0026#39;], plugins: [\u0026#39;@babel/plugin-proposal-class-properties\u0026#39;] }); config.module .rule(\u0026#39;images\u0026#39;) .test(/\\.(png|jpg|jpeg|gif)/) .use(\u0026#39;url-loader\u0026#39;) .loader(\u0026#39;url-loader\u0026#39;) .options({ limit: 1 * 1024, name: path.posix.join(\u0026#34;images\u0026#34;,\u0026#34;[name].[ext]\u0026#34;) }) // do not base64-inline SVGs. // https://github.com/facebookincubator/create-react-app/pull/1180 config.module .rule(\u0026#39;svg\u0026#39;) .test(/\\.(svg)(\\?.*)?$/) .use(\u0026#39;url-loader\u0026#39;) .loader(\u0026#39;url-loader\u0026#39;) .options({ limit: 1024 * 3,//30kb fallback: \u0026#39;file-loader\u0026#39; }) config.module .rule(\u0026#34;fonts\u0026#34;) .test(/\\.(woff2?|eot|ttf|otf)(\\?.*)?$/i) .use(\u0026#39;url-loader\u0026#39;) .loader(\u0026#39;url-loader\u0026#39;) .options({ limit: 10000, fallback: { loader: \u0026#39;file-loader\u0026#39;, options: { name: path.posix.join(\u0026#34;fonts\u0026#34;,\u0026#34;[name].[ext]\u0026#34;) } } }); config.when(isProd,config=\u0026gt;{ config.module.rule(\u0026#34;css\u0026#34;).test(/\\.(sa|sc|c)ss$/) .use(\u0026#34;style\u0026#34;).loader(MiniCssExtractPlugin.loader); }).when(!isProd,config=\u0026gt;{ config.module.rule(\u0026#34;css\u0026#34;).test(/\\.(sa|sc|c)ss$/) .use(\u0026#34;style-loader\u0026#34;).loader(\u0026#34;style-loader\u0026#34;); }); config.module.rule(\u0026#34;css\u0026#34;).test(/\\.(sa|sc|c)ss$/) .use(\u0026#39;css\u0026#39;).loader(\u0026#34;css-loader\u0026#34;).end() .use(\u0026#39;postcss-loader\u0026#39;).loader(\u0026#39;postcss-loader\u0026#39;); config.module.rule(\u0026#34;scss\u0026#34;).test(/\\.(sa|sc)ss$/).use(\u0026#34;sass-loader\u0026#34;).loader(\u0026#34;sass-loader\u0026#34;); config.module.rule(\u0026#34;lass\u0026#34;).test(/\\.less$/).use(\u0026#34;less-loader\u0026#34;).loader(\u0026#34;less-loader\u0026#34;); //config.module.rule(\u0026#34;html\u0026#34;).test(/\\.(htm|html)$/i).use(\u0026#34;html\u0026#34;).loader(\u0026#39;html-withimg-loader\u0026#39;); /** * plugin */ config.when(isProd,config=\u0026gt;{ const UglifyJSPlugin = require(\u0026#39;uglifyjs-webpack-plugin\u0026#39;); const CleanWebpackPlugin = require(\u0026#39;clean-webpack-plugin\u0026#39;); const CopyWebpackPlugin = require(\u0026#34;copy-webpack-plugin\u0026#34;); config.plugin(\u0026#34;clear\u0026#34;).use(new CleanWebpackPlugin([path.join(__dirname, \u0026#39;dist\u0026#39;)])); config.optimization.splitChunks({ cacheGroups: { commons: { chunks: \u0026#34;initial\u0026#34;, name: \u0026#34;common\u0026#34;, minChunks: 2, maxInitialRequests: 5, // The default limit is too small to showcase the effect minSize: 0, // This is example is too small to create commons chunks reuseExistingChunk: true // 可设置是否重用该chunk（查看源码没有发现默认值） } } }); config.plugin(\u0026#34;js\u0026#34;).use(new UglifyJSPlugin({})); config.plugin(\u0026#39;extract-css\u0026#39;) .use(MiniCssExtractPlugin, [{ filename: \u0026#34;css/[name].css\u0026#34;, chunkFilename: \u0026#34;css/[name].css\u0026#34; }]); // config.plugin(\u0026#39;copy\u0026#39;).use(new CopyWebpackPlugin([ // { // from:\u0026#34;./src/sass\u0026#34;, // } // ])) }) const HtmlWebpackPlugin = require(\u0026#39;html-webpack-plugin\u0026#39;); config.plugin(\u0026#34;html\u0026#34;).use(HtmlWebpackPlugin, [{ /* template 参数指定入口 html 文件路径，插件会把这个文件交给 webpack 去编译， webpack 按照正常流程，找到 loaders 中 test 条件匹配的 loader 来编译，那么这里 html-loader 就是匹配的 loader html-loader 编译后产生的字符串，会由 html-webpack-plugin 储存为 html 文件到输出目录，默认文件名为 index.html 可以通过 filename 参数指定输出的文件名 html-webpack-plugin 也可以不指定 template 参数，它会使用默认的 html 模板。 */ template: \u0026#34;./public/index.html\u0026#34;, filename:\u0026#34;index.html\u0026#34;, /* 因为和 webpack 4 的兼容性问题，chunksSortMode 参数需要设置为 none https://github.com/jantimon/html-webpack-plugin/issues/870 */ chunksSortMode: \u0026#39;none\u0026#39;, xhtml: true, minify: { collapseWhitespace: false, //删除空格，但是不会删除SCRIPT、style和textarea中的空格 conservativeCollapse: false, //删除空格，总是保留一个空格 removeAttributeQuotes: false, //删除引号，删除不需要引号的值 useShortDoctype: false, //使用短的文档类型 removeComments: true, collapseBooleanAttributes: true, removeScriptTypeAttributes: true // more options: // https://github.com/kangax/html-minifier#options-quick-reference } }]); config.when(isProd,config=\u0026gt;{ }).when(!isProd,config=\u0026gt;{ config.devServer.host(\u0026#39;localhost\u0026#39;).port(8080).open(process.os === \u0026#39;darwin\u0026#39;); }) config.resolve.alias.set(\u0026#34;@\u0026#34;,path.join(__dirname,\u0026#34;src\u0026#34;)); // Export the completed configuration object to be consumed by webpack module.exports = config.toConfig(); 添加启动脚本 修改package.json文件中scripts节点，加入如下配置:\n1 2 3 4 \u0026#34;scripts\u0026#34;: { \u0026#34;dev\u0026#34;: \u0026#34;cross-env NODE_ENV=development webpack-dev-server\u0026#34;, \u0026#34;build\u0026#34;: \u0026#34;cross-env NODE_ENV=production webpack\u0026#34; } 创建postcss.config.js 1 2 3 4 5 6 7 8 9 10 11 12 13 module.exports = { plugins: { autoprefixer: { \u0026#34;browsers\u0026#34;: [ \u0026#34;ie \u0026gt;= 9\u0026#34;, \u0026#34;ff \u0026gt;= 30\u0026#34;, \u0026#34;chrome \u0026gt;= 34\u0026#34;, \u0026#34;safari \u0026gt;= 7\u0026#34;, \u0026#34;opera \u0026gt;= 23\u0026#34; ] } } } 创建src/index.js 1 2 3 4 5 export default class demo { constructor(){ console.log(\u0026#34;init\u0026#34;); } } 创建example/index.js 1 2 3 import Demo from \u0026#34;../src/index\u0026#34;; const demo = new Demo(); 根目录创建index.html 启动 1 yarn run dev ","date":"2018-11-02T16:00:00Z","permalink":"https://tianhui.xin/p/webpack4-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"webpack4 开发环境搭建"},{"content":"kafka 环境搭建\n安装 下载kafka 1 curl -L -O https://mirrors.cnnic.cn/apache/kafka/2.0.0/kafka_2.12-2.0.0.tgz 解压 1 tar -xvf kafka_2.12-2.0.0.tgz -C /usr/local/kafka 配置zookeeper zookeeper安装\n配置zookeeper 1 vi config/server.properties 找到zookeeper.connect，并将值修改为zookeeper的地址，如\n1 zookeeper.connect=localhost:2181 启动kafka 1 /usr/local/kafka/bin/kafka-server-start.sh /usr/local/kafka/config/server.properties 查看kafka是否启动 1 netstat -tunlp|egrep \u0026#34;(2181|9092)\u0026#34; 单机测试 启动两个xshell客户端分别作为生产者和消费者\n生产者测试 1 2 ./kafka-console-producer.sh --broker-list localhost:9092 --topic test \u0026gt; hello world! 消费者测试 1 ./kafka-console-consumer.sh --bootstrap-server localhost:9092 --topic test --from-beginning 注意: 早期的kafka版本，消费者参数用的是**\u0026ndash;zookeeper**，填写的值是zookeeper的地址，在我们今天教程中的版本参数应该是 \u0026ndash;bootstrap-server,填写的是kafka的broker地址\n查看topic 1 ./kafka-topics.sh --list --zookeeper localhost:2181 ","date":"2018-10-22T11:00:00Z","image":"https://image.tianhui.xin/kafka/1.jpg?x-oss-process=style/make","permalink":"https://tianhui.xin/p/kafka-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"kafka 环境搭建"},{"content":"zookeeper 集群环境安装和搭建\n选择自己的安装目录,下载 zookeeper并解压 1 2 wget http://mirrors.hust.edu.cn/apache/zookeeper/zookeeper-3.4.10/zookeeper-3.4.10.tar.gz tar -xvzf zookeeper-3.4.10.tar.gz 重命名 1 mv zookeeper-3.4.10 zookeeper 配置调整 1 2 3 4 5 6 7 8 9 10 11 12 cd zookeeper/conf mv zoo_sample.cfg zoo.cfg vi zoo.cfg ## 修改以下内容或者新增 dataDir=/usr/local/zookeeper/data dataLogDir=/usr/local/zookeeper/log server.1=host1:8888:9999 server.2=host2:8888:9999 server.3=host3:8888:9999 ## 主机名:用于zookeeper 集群间数据同步传输:用于zookeeper 的选举机制 ------------------------------------------- 创建文件夹 1 2 3 cd zookeeper mkdir data mkdir log 根据dataDir配置myid 1 2 3 4 5 6 7 ## 注意，这里三条服务器不一样 ## 比如我配置的三个server，myid里面写的X就是server.X=ip:8888:9999 中ip所对应的X ## 直接在文件中写对对应的x即可 echo x \u0026gt; myid ## 或者 vi myid 配置完成后，同步给其他节点，并修改配置文件myid中的值 启动服务器 1 2 3 cd zookeeper/bin ./zkServer.sh start \u0026amp; ## 输出：Starting zookeeper ... STARTED 表示启动成功 配置环境变量 1 2 3 4 5 6 7 8 9 vi /etc/profile ##添加下面内容，并保存 export ZOOKEEPER_HOME=/usr/local/zookeeper export PATH=$PATH:$ZOOKEEPER_HOME/bin ## 刷新环境变量 source /etc/profile 工具 1 2 3 4 ##查看是否启动成功 zkServer.sh status ##查看启动过程 zkServer.sh start-foreground ","date":"2018-10-03T21:00:00Z","image":"https://image.tianhui.xin/zooKeeper/timg.jpg?x-oss-process=style/make","permalink":"https://tianhui.xin/p/zookeeper-%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","title":"zookeeper 集群环境搭建"},{"content":"Vue CLi 3快速入门\n2018年08月13日在开源中国收到了Vue CLi 3.0 正式版的发布，关于它的横空出世，晨在这里简单说一下，很多人在微博都在调侃Vue,说是不是更新太块了，都学不过来，下面是我搜集的几张图，\n解释一下，Vue这次并没有发布新版本，而是出了一个简化配置的脚手架，命名为Vue CLi 3，不过调侃小右的也是用尽了各种技能。\n好了，言归正传，回归我们今日的正题，快速入门Vue CLi 3，打开官方文档我们都能看到\nVue CLI 的包名称由 vue-cli 改成了 @vue/cli。 如果你已经全局安装了旧版本的 vue-cli (1.x 或 2.x)，你需要先通过 npm uninstall vue-cli -g 或 yarn global remove vue-cli 卸载它。\n安装的细节，我们这里不做过多的阐述，具体的可以查看官方文档Vue CLi 3\n创建项目 1 vue create hello-world 刚入门，一直回车就好，🙂\n目录结构是啥样子的，让我们看一下\n@vue/cli在这次发布中，到底更新了什么呢，首先要说的第一个东西就是简化配置文件，集中配置文件到vue.config.js中,文件在哪呢，木有啊，那是因为@vue/cli做了一些默认的配置。我们可以自己创建一个这样的文件。\nvue inspect，是脚手架提供的一个配置检查的服务，并且生成一个你很熟悉的文件\n1 vue inspect \u0026gt; output.js 那么这样，是不是很熟悉呢\n是的，这个webpack的一些配置项，那么我们应该怎么书写呢，语法是这样的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // vue.config.js module.exports = { configureWebpack: { plugins: [ new MyAwesomeWebpackPlugin() ] }, chainWebpack: config =\u0026gt; { // GraphQL Loader config.module .rule(\u0026#39;graphql\u0026#39;) .test(/\\.graphql$/) .use(\u0026#39;graphql-tag/loader\u0026#39;) .loader(\u0026#39;graphql-tag/loader\u0026#39;) .end() } } 那么，chainWebpack这是个什么东西，作者采用了webpack-chain的思想，内部实现也是webpack-chain来实现webpack的配置，仔细看 webpack-chain的文档就会看出，它是一个链式API的方式来简化配置的一个插件。\n晨这边也修改过几个loader,大概分享一下代码吧\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 module.exports = { chainWebpack: config =\u0026gt; { config.module.rule(\u0026#39;compile\u0026#39;) .test(/\\.js$/) .include.add(\u0026#39;./examples\u0026#39;).add(\u0026#39;./packages\u0026#39;).end() .use(\u0026#39;babel\u0026#39;) .loader(\u0026#39;babel-loader\u0026#39;) .options({ presets: [ [\u0026#39;babel-preset-es2015\u0026#39;, {modules: false}] ] }); // https://github.com/friends-of-js/yaml-loader config.module.rule(\u0026#34;yml\u0026#34;) .test(/\\.ya?ml$/) .use(\u0026#39;yaml\u0026#39;) .loader(\u0026#39;@friends-of-js/yaml-loader\u0026#39;) .options({ useNodeEnv: true }); } } vue ui 最后我们来介绍另一个东西，对，没错，现在要说的就是vue ui,它是做什么的呢？\n项目管理，包括创建和导入 插件管理，包括依赖管理 任务启动及监控 目前该ui属于Beta版本，可能会出现bug,相信社区会让其更加完善和强大。\n","date":"2018-08-24T21:00:00Z","image":"https://image.tianhui.xin/Vue-CLi/12.png","permalink":"https://tianhui.xin/p/vue-cli-3%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/","title":"Vue CLi 3快速入门"},{"content":"springBoot系列 - 集成JWT实现接口权限认证\n一般来讲，对于RESTful API都会有认证(Authentication)和授权(Authorization)过程，保证API的安全性。\nAuthentication vs. Authorization\nAuthentication指的是确定这个用户的身份，Authorization是确定该用户拥有什么操作权限。\n认证方式一般有三种\nBasic Authentication 这种方式是直接将用户名和密码放到Header中，使用Authorization: Basic Zm9vOmJhcg==，使用最简单但是最不安全。\nTOKEN认证 这种方式也是再HTTP头中，使用Authorization: Bearer ，使用最广泛的TOKEN是JWT，通过签名过的TOKEN。\nOAuth2.0 这种方式安全等级最高，但是也是最复杂的。如果不是大型API平台或者需要给第三方APP使用的，没必要整这么复杂。 一般项目中的RESTful API使用JWT来做认证就足够了。\n什么是JWT Json web token (JWT), 是为了在网络应用环境间传递声明而执行的一种基于JSON的开放标准（(RFC 7519).该token被设计为紧凑且安全的， 特别适用于分布式站点的单点登录（SSO）场景。JWT的声明一般被用来在身份提供者和服务提供者间传递被认证的用户身份信息， 以便于从资源服务器获取资源，也可以增加一些额外的其它业务逻辑所必须的声明信息，该token也可直接被用于认证，也可被加密。\nJWT官网：https://jwt.io/\nJWT是由三段信息构成的，将这三段信息文本用.链接一起就构成了Jwt字符串。就像这样:\n1 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ JWT的构成 第一部分我们称它为头部（header),第二部分我们称其为载荷（payload, 类似于飞机上承载的物品)，第三部分是签证（signature)。\nheader\njwt的头部承载两部分信息：\n声明类型，这里是jwt 声明加密的算法 通常直接使用 HMAC SHA256 这里的加密算法是单向函数散列算法，常见的有MD5、SHA、HAMC。这里使用基于密钥的Hash算法HMAC生成散列值。\nMD5 message-digest algorithm 5 （信息-摘要算法）缩写，广泛用于加密和解密技术，常用于文件校验。校验？不管文件多大，经过MD5后都能生成唯一的MD5值 SHA (Secure Hash Algorithm，安全散列算法），数字签名等密码学应用中重要的工具，安全性高于MD5 HMAC (Hash Message Authentication Code，散列消息鉴别码，基于密钥的Hash算法的认证协议。用公开函数和密钥产生一个固定长度的值作为认证标识，用这个标识鉴别消息的完整性。 常用于接口签名验证完整的头部就像下面这样的JSON：\n1 2 3 4 { \u0026#39;typ\u0026#39;: \u0026#39;JWT\u0026#39;, \u0026#39;alg\u0026#39;: \u0026#39;HS256\u0026#39; } 然后将头部进行base64加密（该加密是可以对称解密的),构成了第一部分\n1 eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9 playload\n载荷就是存放有效信息的地方，这些有效信息包含三个部分：\n标准中注册的声明 公共的声明 私有的声明 标准中注册的声明 (建议但不强制使用) ：\niss: jwt签发者 sub: jwt所面向的用户 aud: 接收jwt的一方 exp: jwt的过期时间，这个过期时间必须要大于签发时间 nbf: 定义在什么时间之前，该jwt都是不可用的. iat: jwt的签发时间 jti: jwt的唯一身份标识，主要用来作为一次性token,从而回避重放攻击。 公共的声明：\n公共的声明可以添加任何的信息，一般添加用户的相关信息或其他业务需要的必要信息.但不建议添加敏感信息，因为该部分在客户端可解密\n私有的声明：\n私有声明是提供者和消费者所共同定义的声明，一般不建议存放敏感信息，因为base64是对称解密的，意味着该部分信息可以归类为明文信息。\n定义一个payload:\n1 2 3 4 5 { \u0026#34;sub\u0026#34;: \u0026#34;1234567890\u0026#34;, \u0026#34;name\u0026#34;: \u0026#34;John Doe\u0026#34;, \u0026#34;admin\u0026#34;: true } 然后将其进行base64加密，得到Jwt的第二部分：\n1 eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9 signature\njwt的第三部分是一个签证信息，这个签证信息由三部分组成：\nheader (base64后的) payload (base64后的) secret 这个部分需要base64加密后的header和base64加密后的payload使用.连接组成的字符串， 然后通过header中声明的加密方式进行加盐secret组合加密，然后就构成了jwt的第三部分。\n1 2 3 // javascript var encodedString = base64UrlEncode(header) + \u0026#39;.\u0026#39; + base64UrlEncode(payload); var signature = HMACSHA256(encodedString, \u0026#39;secret\u0026#39;); // TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ 将这三部分用.连接成一个完整的字符串,构成了最终的jwt:\neyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiYWRtaW4iOnRydWV9.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ\n==注意==：secret是保存在服务器端的，jwt的签发生成也是在服务器端的，secret就是用来进行jwt的签发和jwt的验证， 所以，它就是你服务端的私钥，在任何场景都不应该流露出去。一旦客户端得知这个secret, 那就意味着客户端是可以自我签发jwt了。\n如何应用 一般是在请求头里加入Authorization，并加上Bearer标注：\n1 2 3 4 5 fetch(\u0026#39;api/user/1\u0026#39;, { headers: { \u0026#39;Authorization\u0026#39;: \u0026#39;Bearer \u0026#39; + token } }) 服务器负责解析这个HTTP头来做用户认证和授权处理。大致流程如下：\n安全相关 JWT协议本身不具备安全传输功能，所以必须借助于SSL/TLS的安全通道，所以建议如下：\n不应该在jwt的payload部分存放敏感信息，因为该部分是客户端可解密的部分。 保护好secret私钥，该私钥非常重要。 如果可以，请使用https协议 和SpringBoot集成 简要的说明下我们为什么要用JWT，因为我们要实现完全的前后端分离，所以不可能使用session，cookie的方式进行鉴权， 所以JWT就被派上了用场，可以通过一个加密密钥来进行前后端的鉴权。\n程序逻辑\n我们POST用户名与密码到/login进行登入，如果成功返回一个加密token，失败的话直接返回401错误。 之后用户访问每一个需要权限的网址请求必须在header中添加Authorization字段，例如Authorization: token，token为密钥。 后台会进行token的校验，如果不通过直接返回401。 这里我讲一下如何在SpringBoot中使用JWT来做接口权限认证，安全框架依旧使用Shiro，JWT的实现使用 jjwt\n添加Maven依赖 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-tomcat\u0026lt;/artifactId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-jetty\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.auth0\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;java-jwt\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.3.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- shiro 权限控制 --\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-spring\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;!-- shiro ehcache (shiro缓存)--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.apache.shiro\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;shiro-ehcache\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.4.0\u0026lt;/version\u0026gt; \u0026lt;exclusions\u0026gt; \u0026lt;exclusion\u0026gt; \u0026lt;artifactId\u0026gt;slf4j-api\u0026lt;/artifactId\u0026gt; \u0026lt;groupId\u0026gt;org.slf4j\u0026lt;/groupId\u0026gt; \u0026lt;/exclusion\u0026gt; \u0026lt;/exclusions\u0026gt; \u0026lt;/dependency\u0026gt; 创建用户Service 这个在shiro一节讲过如果创建角色权限表，添加用户Service来执行查找用户操作，这里就不多讲具体实现了，只列出关键代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * 通过名称查找用户 * * @param username * @return */ public ManagerInfo findByUsername(String username) { ManagerInfo managerInfo = managerInfoDao.findByUsername(username); if (managerInfo == null) { throw new UnknownAccountException(); } return managerInfo; } 用户信息类： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class ManagerInfo implements Serializable { private static final long serialVersionUID = 1L; /** * 主键ID */ private Integer id; /** * 账号 */ private String username; /** * 密码 */ private String password; /** * md5密码盐 */ private String salt; /** * 一个管理员具有多个角色 */ private List\u0026lt;SysRole\u0026gt; roles; JWT工具类 我们写一个简单的JWT加密，校验工具，并且使用用户自己的密码充当加密密钥， 这样保证了token 即使被他人截获也无法破解。并且我们在token中附带了username信息，并且设置密钥5分钟就会过期。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 public class JWTUtil { // 过期时间5分钟 private static final long EXPIRE_TIME = 5 * 60 * 1000; /** * 校验token是否正确 * * @param token 密钥 * @param secret 用户的密码 * @return 是否正确 */ public static boolean verify(String token, String username, String secret) { try { Algorithm algorithm = Algorithm.HMAC256(secret); JWTVerifier verifier = JWT.require(algorithm) .withClaim(\u0026#34;username\u0026#34;, username).build(); DecodedJWT jwt = verifier.verify(token); return true; } catch (Exception exception) { return false; } } /** * 获得token中的信息无需secret解密也能获得 * * @return token中包含的用户名 */ public static String getUsername(String token) { try { DecodedJWT jwt = JWT.decode(token); return jwt.getClaim(\u0026#34;username\u0026#34;).asString(); } catch (JWTDecodeException e) { return null; } } /** * 生成签名,5min后过期 * * @param username 用户名 * @param secret 用户的密码 * @return 加密的token */ public static String sign(String username, String secret) { try { Date date = new Date(System.currentTimeMillis() + EXPIRE_TIME); Algorithm algorithm = Algorithm.HMAC256(secret); // 附带username信息 return JWT.create().withClaim(\u0026#34;username\u0026#34;, username) .withExpiresAt(date).sign(algorithm); } catch (UnsupportedEncodingException e) { return null; } } } 编写登录接口 为了让用户登录的时候获取到正确的JWT Token，需要实现登录接口，这里我编写一个LoginController.java：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 RestController public class LoginController { private static final Logger _logger = LoggerFactory.getLogger(LoginController.class); @Resource private ManagerInfoService managerInfoService; @PostMapping(\u0026#34;/login\u0026#34;) public BaseResponse login(@RequestParam(\u0026#34;username\u0026#34;) String username, @RequestParam(\u0026#34;password\u0026#34;) String password) { ManagerInfo user = managerInfoService.findByUsername(username); //盐（用户名+随机数） String salt = user.getSalt(); //原密码 String encodedPassword = ShiroKit.md5(password, username + salt); if (user.getPassword().equals(encodedPassword)) { return new BaseResponse(true, \u0026#34;Login success\u0026#34;, JWTUtil.sign(username, encodedPassword)); } else { throw new UnauthorizedException(); } } @RequestMapping(path = \u0026#34;/401\u0026#34;) @ResponseStatus(HttpStatus.UNAUTHORIZED) public BaseResponse unauthorized() { return new BaseResponse(false, \u0026#34;Unauthorized\u0026#34;, null); } } 注意上面登录的时候，我会从数据库中把这个用户取出来，密码加盐算MD5值比较，通过之后再用密码作为密钥来签名生成JWT。\n编写RESTful接口 先编写一个通用的接口返回类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 /** * API接口的基础返回类 * * @author XiongNeng * @version 1.0 * @since 2018/1/7 */ public class BaseResponse\u0026lt;T\u0026gt; { /** * 是否成功 */ private boolean success; /** * 说明 */ private String msg; /** * 返回数据 */ private T data; public BaseResponse() { } public BaseResponse(boolean success, String msg, T data) { this.success = success; this.msg = msg; this.data = data; } } 通过SpringMVC实现RESTful接口，这里我只写一个示例方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @RestController @RequestMapping(value = \u0026#34;/api/v1\u0026#34;) public class PublicController { @Resource private ApiService apiService; /** * 请求入网接口 * * @return 处理结果 */ @RequestMapping(value = \u0026#34;/join\u0026#34;, method = RequestMethod.POST) @RequiresRoles(\u0026#34;admin\u0026#34;) public ResponseEntity\u0026lt;BaseResponse\u0026gt; doJoin(@RequestBody PosParam posParam) { _logger.info(\u0026#34;请求入网接口 start....\u0026#34;); BaseResponse result = new BaseResponse(); // imei码约束检查 if (StringUtils.isEmpty(posParam.getImei()) || posParam.getImei().length() \u0026gt; 32) { result.setSuccess(false); result.setMsg(\u0026#34;IMEI码长度不是1-32位，入网失败。\u0026#34;); return new ResponseEntity\u0026lt;\u0026gt;(result, HttpStatus.OK); } Pos pos = new Pos(); Date now = new Date(); pos.setJointime(now); pos.setBindtime(now); BeanUtils.copyProperties(posParam, pos); // 插入一条新纪录 pos.setProjectId(project.getId()); int insert = apiService.insertPos(pos); if (insert \u0026gt; 0) { result.setSuccess(true); result.setMsg(\u0026#34;入网成功\u0026#34;); return new ResponseEntity\u0026lt;\u0026gt;(result, HttpStatus.CREATED); } else { result.setSuccess(false); result.setMsg(\u0026#34;入网失败，请联系管理员。\u0026#34;); return new ResponseEntity\u0026lt;\u0026gt;(result, HttpStatus.OK); } } } 自定义异常 为了实现我自己能够手动抛出异常，我自己写了一个UnauthorizedException.java\n1 2 3 4 5 6 7 8 9 public class UnauthorizedException extends RuntimeException { public UnauthorizedException(String msg) { super(msg); } public UnauthorizedException() { super(); } } 处理框架异常 之前说过restful要统一返回的格式，所以我们也要全局处理Spring Boot的抛出异常。利用@RestControllerAdvice能很好的实现。 注意这个统一异常处理器只对认证过的用户调用接口中的异常有作用，对AuthenticationException没有用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @RestControllerAdvice public class ExceptionController { // 捕捉shiro的异常 @ResponseStatus(HttpStatus.UNAUTHORIZED) @ExceptionHandler(ShiroException.class) public BaseResponse handle401(ShiroException e) { return new BaseResponse(false, \u0026#34;shiro的异常\u0026#34;, null); } // 捕捉UnauthorizedException @ResponseStatus(HttpStatus.UNAUTHORIZED) @ExceptionHandler(UnauthorizedException.class) public BaseResponse handle401() { return new BaseResponse(false, \u0026#34;UnauthorizedException\u0026#34;, null); } // 捕捉其他所有异常 @ExceptionHandler(Exception.class) @ResponseStatus(HttpStatus.BAD_REQUEST) public BaseResponse globalException(HttpServletRequest request, Throwable ex) { return new BaseResponse(false, \u0026#34;其他异常\u0026#34;, null); } private HttpStatus getStatus(HttpServletRequest request) { Integer statusCode = (Integer) request.getAttribute(\u0026#34;javax.servlet.error.status_code\u0026#34;); if (statusCode == null) { return HttpStatus.INTERNAL_SERVER_ERROR; } return HttpStatus.valueOf(statusCode); } } 配置Shiro 大家可以先看下官方的Spring-Shiro整合教程，有个初步的了解。 不过既然我们用了SpringBoot，那我们肯定要争取零配置文件。\n实现JWTToken\nJWTToken差不多就是Shiro用户名密码的载体。因为我们是前后端分离，服务器无需保存用户状态，所以不需要RememberMe这类功能， 我们简单的实现下AuthenticationToken接口即可。因为token自己已经包含了用户名等信息，所以这里我就弄了一个字段。 如果你喜欢钻研，可以看看官方的UsernamePasswordToken是如何实现的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class JWTToken implements AuthenticationToken { // 密钥 private String token; public JWTToken(String token) { this.token = token; } @Override public Object getPrincipal() { return token; } @Override public Object getCredentials() { return token; } } 实现Realm\nrealm的用于处理用户是否合法的这一块，需要我们自己实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 /** * Description : 身份校验核心类 */ public class MyShiroRealm extends AuthorizingRealm { private static final Logger _logger = LoggerFactory.getLogger(MyShiroRealm.class); @Autowired ManagerInfoService managerInfoService; /** * JWT签名密钥，这里没用。我使用的是用户的MD5密码作为签名密钥 */ public static final String SECRET = \u0026#34;9281e268b77b7c439a20b46fd1483b9a\u0026#34;; /** * 必须重写此方法，不然Shiro会报错 */ @Override public boolean supports(AuthenticationToken token) { return token instanceof JWTToken; } /** * 认证信息(身份验证) * Authentication 是用来验证用户身份 * * @param auth * @return * @throws AuthenticationException */ @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken auth) throws AuthenticationException { _logger.info(\u0026#34;MyShiroRealm.doGetAuthenticationInfo()\u0026#34;); String token = (String) auth.getCredentials(); // 解密获得username，用于和数据库进行对比 String username = JWTUtil.getUsername(token); if (username == null) { throw new AuthenticationException(\u0026#34;token invalid\u0026#34;); } //通过username从数据库中查找 ManagerInfo对象 //实际项目中，这里可以根据实际情况做缓存，如果不做，Shiro自己也是有时间间隔机制，2分钟内不会重复执行该方法 ManagerInfo managerInfo = managerInfoService.findByUsername(username); if (managerInfo == null) { throw new AuthenticationException(\u0026#34;User didn\u0026#39;t existed!\u0026#34;); } if (!JWTUtil.verify(token, username, managerInfo.getPassword())) { throw new AuthenticationException(\u0026#34;Username or password error\u0026#34;); } return new SimpleAuthenticationInfo(token, token, \u0026#34;my_realm\u0026#34;); } /** * 此方法调用hasRole,hasPermission的时候才会进行回调. * \u0026lt;p\u0026gt; * 权限信息.(授权): * 1、如果用户正常退出，缓存自动清空； * 2、如果用户非正常退出，缓存自动清空； * 3、如果我们修改了用户的权限，而用户不退出系统，修改的权限无法立即生效。 * （需要手动编程进行实现；放在service进行调用） * 在权限修改后调用realm中的方法，realm已经由spring管理，所以从spring中获取realm实例，调用clearCached方法； * :Authorization 是授权访问控制，用于对用户进行的操作授权，证明该用户是否允许进行当前操作，如访问某个链接，某个资源文件等。 * * @param principals * @return */ @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) { /* * 当没有使用缓存的时候，不断刷新页面的话，这个代码会不断执行， * 当其实没有必要每次都重新设置权限信息，所以我们需要放到缓存中进行管理； * 当放到缓存中时，这样的话，doGetAuthorizationInfo就只会执行一次了， * 缓存过期之后会再次执行。 */ _logger.info(\u0026#34;权限配置--\u0026gt;MyShiroRealm.doGetAuthorizationInfo()\u0026#34;); String username = JWTUtil.getUsername(principals.toString()); // 下面的可以使用缓存提升速度 ManagerInfo managerInfo = managerInfoService.findByUsername(username); SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo(); //设置相应角色的权限信息 for (SysRole role : managerInfo.getRoles()) { //设置角色 authorizationInfo.addRole(role.getRole()); for (Permission p : role.getPermissions()) { //设置权限 authorizationInfo.addStringPermission(p.getPermission()); } } return authorizationInfo; } } 在doGetAuthenticationInfo中用户可以自定义抛出很多异常，详情见文档。\n重写Filter\n所有的请求都会先经过Filter，所以我们继承官方的BasicHttpAuthenticationFilter，并且重写鉴权的方法， 另外通过重写preHandle，实现跨越访问。\n代码的执行流程preHandle-\u0026gt;isAccessAllowed-\u0026gt;isLoginAttempt-\u0026gt;executeLogin\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 public class JWTFilter extends BasicHttpAuthenticationFilter { private Logger LOGGER = LoggerFactory.getLogger(this.getClass()); /** * 判断用户是否想要登入。 * 检测header里面是否包含Authorization字段即可 */ @Override protected boolean isLoginAttempt(ServletRequest request, ServletResponse response) { HttpServletRequest req = (HttpServletRequest) request; String authorization = req.getHeader(\u0026#34;Authorization\u0026#34;); return authorization != null; } /** * */ @Override protected boolean executeLogin(ServletRequest request, ServletResponse response) throws Exception { HttpServletRequest httpServletRequest = (HttpServletRequest) request; String authorization = httpServletRequest.getHeader(\u0026#34;Authorization\u0026#34;); JWTToken token = new JWTToken(authorization); // 提交给realm进行登入，如果错误他会抛出异常并被捕获 getSubject(request, response).login(token); // 如果没有抛出异常则代表登入成功，返回true return true; } /** * 这里我们详细说明下为什么最终返回的都是true，即允许访问 * 例如我们提供一个地址 GET /article * 登入用户和游客看到的内容是不同的 * 如果在这里返回了false，请求会被直接拦截，用户看不到任何东西 * 所以我们在这里返回true，Controller中可以通过 subject.isAuthenticated() 来判断用户是否登入 * 如果有些资源只有登入用户才能访问，我们只需要在方法上面加上 @RequiresAuthentication 注解即可 * 但是这样做有一个缺点，就是不能够对GET,POST等请求进行分别过滤鉴权(因为我们重写了官方的方法)，但实际上对应用影响不大 */ @Override protected boolean isAccessAllowed(ServletRequest request, ServletResponse response, Object mappedValue) { if (isLoginAttempt(request, response)) { try { executeLogin(request, response); } catch (Exception e) { response401(request, response); } } return true; } /** * 对跨域提供支持 */ @Override protected boolean preHandle(ServletRequest request, ServletResponse response) throws Exception { HttpServletRequest httpServletRequest = (HttpServletRequest) request; HttpServletResponse httpServletResponse = (HttpServletResponse) response; httpServletResponse.setHeader(\u0026#34;Access-control-Allow-Origin\u0026#34;, httpServletRequest.getHeader(\u0026#34;Origin\u0026#34;)); httpServletResponse.setHeader(\u0026#34;Access-Control-Allow-Methods\u0026#34;, \u0026#34;GET,POST,OPTIONS,PUT,DELETE\u0026#34;); httpServletResponse.setHeader(\u0026#34;Access-Control-Allow-Headers\u0026#34;, httpServletRequest.getHeader(\u0026#34;Access-Control-Request-Headers\u0026#34;)); // 跨域时会首先发送一个option请求，这里我们给option请求直接返回正常状态 if (httpServletRequest.getMethod().equals(RequestMethod.OPTIONS.name())) { httpServletResponse.setStatus(HttpStatus.OK.value()); return false; } return super.preHandle(request, response); } /** * 将非法请求跳转到 /401 */ private void response401(ServletRequest req, ServletResponse resp) { try { HttpServletResponse httpServletResponse = (HttpServletResponse) resp; httpServletResponse.sendRedirect(\u0026#34;/401\u0026#34;); } catch (IOException e) { LOGGER.error(e.getMessage()); } } } 编写ShiroConfig配置类\n这里我还增加了EhCache缓存管理支持，不需要每次都调用数据库做授权。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 @Configuration @Order(1) public class ShiroConfig { /** * ShiroFilterFactoryBean 处理拦截资源文件问题。 * 注意：单独一个ShiroFilterFactoryBean配置是或报错的，以为在 * 初始化ShiroFilterFactoryBean的时候需要注入：SecurityManager Filter Chain定义说明 * 1、一个URL可以配置多个Filter，使用逗号分隔 * 2、当设置多个过滤器时，全部验证通过，才视为通过 * 3、部分过滤器可指定参数，如perms，roles */ @Bean public ShiroFilterFactoryBean shirFilter(SecurityManager securityManager) { ShiroFilterFactoryBean shiroFilterFactoryBean = new ShiroFilterFactoryBean(); // 必须设置 SecurityManager shiroFilterFactoryBean.setSecurityManager(securityManager); //验证码过滤器 Map\u0026lt;String, Filter\u0026gt; filtersMap = shiroFilterFactoryBean.getFilters(); filtersMap.put(\u0026#34;jwt\u0026#34;, new JWTFilter()); shiroFilterFactoryBean.setFilters(filtersMap); // 拦截器 Map\u0026lt;String, String\u0026gt; filterChainDefinitionMap = new LinkedHashMap\u0026lt;String, String\u0026gt;(); // 其他的 filterChainDefinitionMap.put(\u0026#34;/**\u0026#34;, \u0026#34;jwt\u0026#34;); // 访问401和404页面不通过我们的Filter filterChainDefinitionMap.put(\u0026#34;/401\u0026#34;, \u0026#34;anon\u0026#34;); filterChainDefinitionMap.put(\u0026#34;/404\u0026#34;, \u0026#34;anon\u0026#34;); shiroFilterFactoryBean.setFilterChainDefinitionMap(filterChainDefinitionMap); return shiroFilterFactoryBean; } @Bean public SecurityManager securityManager() { DefaultWebSecurityManager securityManager = new DefaultWebSecurityManager(); // 设置realm. securityManager.setRealm(myShiroRealm()); //注入缓存管理器 securityManager.setCacheManager(ehCacheManager()); // 关闭shiro自带的session DefaultSubjectDAO subjectDAO = new DefaultSubjectDAO(); DefaultSessionStorageEvaluator defaultSessionStorageEvaluator = new DefaultSessionStorageEvaluator(); defaultSessionStorageEvaluator.setSessionStorageEnabled(false); subjectDAO.setSessionStorageEvaluator(defaultSessionStorageEvaluator); securityManager.setSubjectDAO(subjectDAO); return securityManager; } /** * 身份认证realm; (这个需要自己写，账号密码校验；权限等) */ @Bean public MyShiroRealm myShiroRealm() { MyShiroRealm myShiroRealm = new MyShiroRealm(); return myShiroRealm; } /** * 开启shiro aop注解支持. 使用代理方式; 所以需要开启代码支持; * * @param securityManager 安全管理器 * @return 授权Advisor */ @Bean public AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor(SecurityManager securityManager) { AuthorizationAttributeSourceAdvisor authorizationAttributeSourceAdvisor = new AuthorizationAttributeSourceAdvisor(); authorizationAttributeSourceAdvisor.setSecurityManager(securityManager); return authorizationAttributeSourceAdvisor; } /** * shiro缓存管理器; * 需要注入对应的其它的实体类中： * 1、安全管理器：securityManager * 可见securityManager是整个shiro的核心； * * @return */ @Bean public EhCacheManager ehCacheManager() { EhCacheManager cacheManager = new EhCacheManager(); cacheManager.setCacheManagerConfigFile(\u0026#34;classpath:ehcache.xml\u0026#34;); return cacheManager; } } 里面URL规则自己参考文档http://shiro.apache.org/web.html ，这个在shiro那篇说的很清楚了。\n运行验证 最后是将代码跑起来验证这一切是否正常。\n启动SpringBoot后，先通过POST请求登录拿到token\n然后在调用入网接口的时候在header中带上这个token认证：\n如果token认证不正确会报异常：\n如果使用普通用户登录，认证正确但是授权访问接口失败，会返回如下的未授权结果：\n参考文章 RESTful API Authentication Basics\n什么是 JWT – JSON WEB TOKEN\nShiro+JWT+Spring Boot Restful简易教程\nGitHub源码 springboot-jwt\n","date":"2018-07-20T21:00:00Z","image":"https://image.tianhui.xin/liveLearn/5/api-security.jpg","permalink":"https://tianhui.xin/p/springboot%E7%B3%BB%E5%88%97-%E9%9B%86%E6%88%90jwt%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3%E6%9D%83%E9%99%90%E8%AE%A4%E8%AF%81/","title":"springBoot系列 - 集成JWT实现接口权限认证"},{"content":"有很多的电影情节，总触动着多数人的心弦，而你我也在相遇相知的路上，越走越远…，或许我，也是一个感性的人，对于爱情，我难免还是有些缓不济急。\n电影讲述着一对北漂的年轻人，十年的光阴，相聚相离，也讲述了北漂的心酸。\n小晓：“为什么从来没有一个故事，从头到尾都是幸福的？”\n见清：“幸福不是故事，不幸才是。”\n小晓：“那我不想和你之间发生什么故事了。\n还有在他们在捡来的沙发上\n小晓：“我们现在这么好，如果以后我们分手了我过的不好，你会开心吗？”\n见清：“不会。”\n小晓：“过得开心呢？”\n见清：“也不会。”\n小晓：“为什么？”\n见清：“因为不是我让你开心的。”\n我相信很多人没有机会认真对前任说这样的话。\n我们没有勇气在再见到前任时问那么多“如果”\n如果当时你没走，后来的我们会不会不一样\n如果当时你有勇气上地铁，我会跟你一辈子\n如果那时你没有跟我分手呢\n那我们之后也会分手\n如果我们一起坚持到最后呢\n那也许你就不会成功\n如果当时我足够有钱，我们住进一个有大沙发的大房子\n那你可能已经找了不下十个小三\n如果当时我们就是不管不顾，我们就是结婚了呢\n那我们离婚好多年了\n如果我们没有离家去北京\n如果没有如果\n后来也没有后来\n后来，我们什么都有了\n却没有了我们\n爱情很美好，可是生活却很艰难。家里很温暖，可是该死的梦想却在远方。\n后来我们什么都有了，可是却没有了彼此。\n在这份感情中，女孩要求的越来越少，最终要的不过是你在意我;\n男孩却想要的越来越多，除了爱，还有自尊心、虚荣心，甚至是新鲜感。\n在回家的车中，关小晓对林见清说：I miss you\n林见清回答：我也想你。\n而关小晓说：我是说我错过了你。\n命运可能就是这样阴差阳错，哪有那么多为什么？林父在给关小晓中的信中写到“你们不负彼此，不必强求不负此生”，我相信看哭了很多人，初听不懂曲中意，听懂已是曲中人。\n看完听完，心里轻轻地疼一下，然后收拾心情，继续完成你现在的生活，也愿你找到能为你“上九天揽月，下五洋捉鳖”的那位。\n素材来自凯说\n","date":"2018-04-30T23:00:00Z","image":"https://image.tianhui.xin/slowLife/8/4.jpg","permalink":"https://tianhui.xin/p/%E5%90%8E%E6%9D%A5%E7%9A%84%E6%88%91%E4%BB%AC/","title":"后来的我们"},{"content":"四月的天，遗失着黄昏的疲倦，撒落的却是花开的光阴。最后的日子里，我们的回忆不散。\n已是人间最美四月天，我们来场说走就走的旅行，四月，这个万花盛开的季节，我们去了哪？\n云蒙山国家森林公园位于密云城区西部。云蒙山，古称云梦山，是京郊有名的自然风景区。公园总面积2208公顷，主峰海拔1414米。园内景观资源丰富，是一座具有山岳风光特征的北京郊外风景名胜区，有北方“小黄山”美称。（裁自某度，嘿嘿）\n我们选择了包车出行，一行二十几人，从北京到附近民宿，也就1个多小时的行程，吃完早饭我们10点到达山脚，在路上选择美团购票，因为我们看到美团的票是有优惠的，到景点问工作人员才知，美团购票必须提前两小时，最终我们无奈的选择了自助购票。\n进入景区，此时我们看到的是高耸的山脉，自成一体的山脉让它从众山中脱颖而出，众人壮志豪言，要感受一下一览众山小的激情，其实崎岖的山路也还可以，有专人用石头搭建的石梯，有使用木头和泥土搭建的简易道路，也有自然而成的路，古人有云，世上本是没有路的，走的人多了，它也就成为了路。\n我们一路嬉戏，按照景点地图一路前行着，路途中，能在山涧中看到山水凝结的冰块并没有随着北京的升温而融化，能看见坚挺的青松绿意盎然，李白曾有诗句,“勗君青松心，努力保霜雪”，赞扬着青松的四季常青。\n观其形意万千的山石，山石峥嵘险峭，山路狭窄像羊肠，那是大自然的鬼斧神工，今年的北京，万花盛开，彷佛有些珊珊来迟，我们并没有看到那映山红的绿叶衬红花，心中总有一种“争奈结根深石底，无因移得到人家”的感触。\n一路的玩耍，伴随饥渴，我们去到主峰的山顶，那里真的能一览纵山小呢，海拔1400多米，从山脚上去，怎么也爬了200层的样子，我并没有能上去，事先并没有看过攻略，一重人每人就带了一瓶水，却都有着“欲与天工试比高”的豪情，跑到半山的时候伙伴们已经饿的不成样子了，路上看见其它登山人士，带着各种吃的喝得，有没有一种想冲上去暴吃的冲动；功夫不负有心人，耐着饥渴，他们顺利到达了顶峰，选择了另一条道下山，而我实在没了力气，最终选择了原路返回。到达主峰山脚的时候，下午四点钟，众人饿的不行，山脚下有当地人在卖东西，不过买的有点贵，但对于此时的我们，贵点也得充饥啊，不然我觉得都难顺利的往返了；商店大爷人挺好，提供扫码支付，不过我跟你讲，你最好带点现金，因为大山没信号，o(∩_∩)o 哈哈\n好了，今天就想辣么多了，我们下次江湖见，记得我们的口号是，天王盖地虎\u0026hellip;\n","date":"2018-04-28T22:00:00Z","image":"https://image.tianhui.xin/slowLife/1.jpg","permalink":"https://tianhui.xin/p/%E4%BA%91%E8%92%99%E5%B1%B1%E4%B8%80%E6%97%A5%E6%B8%B8/","title":"云蒙山一日游"}]